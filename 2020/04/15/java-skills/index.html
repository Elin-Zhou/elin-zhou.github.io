<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PingFang SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.xxelin.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java多线程、JUChappens-before原则 程序顺序规则：一个线程中的某个操作happens-before于后续的操作（如果调转前后的操作后不会改变程序结构，那么这写操作仍可被指令重排） 监视器锁规则：解锁操作前的操作happens-before于之后的上锁操作（及其上锁后的操作）（一般认为的synchronized锁范围内变量的可见性是通过这条规则实现的） volatile变量规则：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java技能图谱">
<meta property="og:url" content="https://www.xxelin.com/2020/04/15/java-skills/index.html">
<meta property="og:site_name" content="奕林的技术博客">
<meta property="og:description" content="Java多线程、JUChappens-before原则 程序顺序规则：一个线程中的某个操作happens-before于后续的操作（如果调转前后的操作后不会改变程序结构，那么这写操作仍可被指令重排） 监视器锁规则：解锁操作前的操作happens-before于之后的上锁操作（及其上锁后的操作）（一般认为的synchronized锁范围内变量的可见性是通过这条规则实现的） volatile变量规则：">
<meta property="og:locale">
<meta property="og:image" content="https://www.xxelin.com/images/bb.jpeg">
<meta property="og:image" content="https://www.xxelin.com/images/image-20200313110844231.png">
<meta property="og:image" content="https://www.xxelin.com/images/20190202175541832.png">
<meta property="og:image" content="https://www.xxelin.com/images/54p47987806747pq8n2465o69on03o3o.jpg">
<meta property="og:image" content="https://www.xxelin.com/images/1200756-20191224143040070-1153407888.png">
<meta property="og:image" content="https://www.xxelin.com/images/4-20200409100840548.png">
<meta property="og:image" content="https://www.xxelin.com/images/640">
<meta property="article:published_time" content="2020-04-15T02:17:40.000Z">
<meta property="article:modified_time" content="2022-05-30T07:18:02.000Z">
<meta property="article:author" content="Elin Zhou">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.xxelin.com/images/bb.jpeg">

<link rel="canonical" href="https://www.xxelin.com/2020/04/15/java-skills/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Java技能图谱 | 奕林的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">奕林的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">撸着代码唱着歌</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Elin-Zhou" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.xxelin.com/2020/04/15/java-skills/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Elin Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奕林的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java技能图谱
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-15 10:17:40" itemprop="dateCreated datePublished" datetime="2020-04-15T10:17:40+08:00">2020-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-30 15:18:02" itemprop="dateModified" datetime="2022-05-30T15:18:02+08:00">2022-05-30</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/04/15/java-skills/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/04/15/java-skills/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="多线程、JUC"><a href="#多线程、JUC" class="headerlink" title="多线程、JUC"></a>多线程、JUC</h3><h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><ul>
<li>程序顺序规则：一个线程中的某个操作happens-before于后续的操作（如果调转前后的操作后不会改变程序结构，那么这写操作仍可被指令重排）</li>
<li>监视器锁规则：解锁操作前的操作happens-before于之后的上锁操作（及其上锁后的操作）（一般认为的synchronized锁范围内变量的可见性是通过这条规则实现的）</li>
<li>volatile变量规则：volatile变量的写操作happens-before于后续对这个变量的读操作（即保证了volatile关键字修饰变量的可见性）</li>
<li>传递性：A happens-before B，B happens-before C ，那么A happens-before C</li>
<li>start()规则：执行Thread.start()前的操作happends-before 于start()启动的线程中执行的操作（即被启动的线程中可以看到启动前的操作）</li>
<li>join()规则：A线程中执行B.join()，那么B线程中的操作happens-before于join()返回后的操作</li>
<li>程序中断规则：对线程interrupt()方法的调用happens-before后续被中断线程中的检测操作</li>
<li>finalize规则：对象的初始化操作happens-before finalize中的操作</li>
</ul>
<h4 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h4><p><code>volatile</code>可以实现内存的可见性和防止指令重排序。</p>
<p>通过内存屏障技术实现的。</p>
<p>为了实现<code>volatile</code>的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障指令，内存屏障效果有：</p>
<ul>
<li>禁止<code>volatile</code> 修饰变量指令的重排序</li>
<li>写入数据强制刷新到主存</li>
<li>读取数据强制从主存读取</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="sychronized原理与对象锁"><a href="#sychronized原理与对象锁" class="headerlink" title="sychronized原理与对象锁"></a>sychronized原理与对象锁</h5><p><code>sychronized</code>能实现有序性和可见性，但不能防止指令重排（所以单例模式中即使使用了双重锁检查，也需要使用volatile关键词（new 操作分三步，如果指令重排了可能会先把对象指向空的内存区域，导致其他线程使用异常））</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff">https://juejin.im/post/5ae6dc04f265da0ba351d3ff</a></p>
<ul>
<li>锁状态：锁可以升级但不能降级<ul>
<li>无锁状态</li>
<li>偏向锁状态：记录第一个获得锁对象的id，如果之后该线程尝试获得锁，就直接放行；如果其他线程尝试获取锁，则判断对象头中记录（持有锁）的线程是否存活，如果不存活则设置为无锁状态，如果存活则判断线程中的锁记录决定撤销锁&#x2F;偏向到当前线程&#x2F;升级锁状态</li>
<li>轻量级锁状态：线程通过CAS将锁对象中的Markword替换成当前对象头中MarkWord，替换成功则执行同步块，如果替换失败，说明存在锁竞争，则自旋，自旋获取仍失败时，修改标记位为重量级锁；执行完同步块需要释放锁的线程同样适用CAS修改Markword，此时发现锁被升级，需要释放锁并唤醒其他等待锁的线程</li>
<li>重量级锁状态：在代码块前后增加monitorenter和monitorexit</li>
</ul>
</li>
</ul>
<h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aeb07ab6fb9a07ac36350c8">https://juejin.im/post/5aeb07ab6fb9a07ac36350c8</a></p>
<p>公平锁与非公平锁的差别是公平锁在请求锁时判断AQS中当前节点是否有前驱节点，如果有，说明有更早的线程在等待锁</p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aeb0a8b518825673a2066f0">https://juejin.im/post/5aeb0a8b518825673a2066f0</a> </p>
<h5 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5aeb0e016fb9a07ab7740d90">https://juejin.im/post/5aeb0e016fb9a07ab7740d90</a></p>
<ul>
<li>读锁是共享锁，写锁是独占锁</li>
<li>读写锁个数保存方式：读锁和写锁保存在AQS的同一个status字段中，读锁个数保存在高16位，写锁保存在低16位</li>
</ul>
<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><p>包含三个概念：写锁、乐观读、读锁。其中读锁和写锁等同于ReentrantReadWriteLock，乐观读相当于数据库中的乐观锁，在读完后判断版本号（stamp）是否过期，如果过期了，就升级为读锁。在多读少写的场景下，性能更胜于ReentrantReadWriteLock。该锁的非可中断方法对中断的响应有bug，会导致CPU100%，如果有响应中断的需求，需要使用可响应中断的方式获取锁。</p>
<h4 id="多线程面试题总结"><a href="#多线程面试题总结" class="headerlink" title="多线程面试题总结"></a>多线程面试题总结</h4><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xrq730/p/5060921.html">http://www.cnblogs.com/xrq730/p/5060921.html</a></p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li>如果当前运行的线程少于corePoolSize，则会创建新的线程来执行新的任务；</li>
<li>如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中；</li>
<li>如果当前workQueue队列已满的话，则会创建新的线程来执行任务；</li>
<li>如果线程个数已经超过了maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来进行处理。</li>
</ul>
<h4 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h4><ol>
<li>直接丢弃任务</li>
<li>丢弃队列中最老的任务</li>
<li>抛出异常</li>
<li>由调用线程同步执行</li>
</ol>
<h4 id="线程数"><a href="#线程数" class="headerlink" title="线程数"></a>线程数</h4><h5 id="学术论"><a href="#学术论" class="headerlink" title="学术论"></a>学术论</h5><ul>
<li>计算密集型：CPU数+1</li>
<li>非计算密集型：CPU数*(1+IO时间&#x2F;CPU时间)</li>
</ul>
<h5 id="经验论"><a href="#经验论" class="headerlink" title="经验论"></a>经验论</h5><ul>
<li>超时时间：TP90+平均值  即允许一次重试</li>
<li>线程数：目标QPS*RT</li>
</ul>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p>CyclicBarrier</p>
<p>CountDownLatch</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="普通集合"><a href="#普通集合" class="headerlink" title="普通集合"></a>普通集合</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ul>
<li>并发环境下出问题的原因：add和remove等方式使用i++或i–方式移动数组指针，由于其为非原子操作，导致数据出错</li>
</ul>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><ul>
<li><p>死循环原因：在多线程环境下resize导致形成环形链表，get操作时将死循环</p>
</li>
<li><p>HashMap扩容每次都是按原大小两倍扩容的原因：<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000020673403/a-1020000020676787">https://segmentfault.com/q/1010000020673403/a-1020000020676787</a></p>
<ol>
<li>寻找某个key所在桶时，原本通过hash%(length-1)的操作，可以简化为hash&amp;(length-1)，按位与操作效率远高于模操作</li>
<li>在rehash过程中，oldTable[i]中的元素只可能分配在newTable[i]或newTable[i+oldCap]，而且只有oldTable[i]中的元素有可能分配到这两个位置。如果不按两倍扩容，则每个元素都需要rehash且随机插入到新的位置中。</li>
</ol>
</li>
</ul>
<h4 id="JUC中集合"><a href="#JUC中集合" class="headerlink" title="JUC中集合"></a>JUC中集合</h4><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><ul>
<li>put<ul>
<li>首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在 table中的位置；</li>
<li>如果当前table数组还未初始化，先将table数组进行初始化操作；</li>
<li>如果这个位置是null的，那么使用CAS操作直接放入；</li>
<li>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点fh&#x3D;&#x3D;MOVED(代表forwardingNode,数组正在进行扩容)的话，说明正在进行扩容；</li>
<li>如果是链表节点（fh&gt;0）,则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到key相同的节点，则只需要覆盖该结点的value值即可。否则依次向后遍历，直到链表尾插入这个结点；</li>
<li>如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点；</li>
<li>插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；</li>
<li>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。</li>
</ul>
</li>
<li>get<ul>
<li>先获取hash值，找到对应的节点</li>
<li>通过节点的hash值判断当前是链表还是树，当节点的hash小于0时表示为树节点</li>
<li>通过对应的数据结构进行查找</li>
</ul>
</li>
</ul>
<h5 id="CopyOnWriteList"><a href="#CopyOnWriteList" class="headerlink" title="CopyOnWriteList"></a>CopyOnWriteList</h5><ul>
<li>跟读写锁比的优点：读操作完全无锁</li>
<li>缺点：数据无法立即可见；占用双倍内存</li>
</ul>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><ul>
<li>内存泄漏问题：因为ThreadLocalMap中的key是弱引用而value不是，当map中的key被gc时，value无法被访问到，但是通过可达性分析却能关联到value，导致内存泄漏</li>
<li>解决方案，ThreadLocal在get，set，remove时均会进行清理</li>
</ul>
<h5 id="ArrayBlockingQueue与LinkedBlockingQueue的差别"><a href="#ArrayBlockingQueue与LinkedBlockingQueue的差别" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue的差别"></a>ArrayBlockingQueue与LinkedBlockingQueue的差别</h5><ul>
<li>ArrayBlockingQueue只用了一个锁，而LinkedBlockingQueue将添加与移除的锁分开，提高了吞吐</li>
<li>LinkedBlockingQueue可以是无界队列，但是ArrayBlockingQueue必须有界</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><h5 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h5><ul>
<li>程序计数器</li>
<li>Java堆</li>
<li>虚拟机栈：执行方法时，创建一个『栈帧』，主要用来存放方法中的局部变量，线程隔离</li>
<li>本地方法栈：同虚拟机栈，差别在于虚拟机栈服务对象是Java方法，而本地方法栈服务的是native方法。</li>
<li>方法区（也称永久代，在Java8中取消了这个分区，其中的内容进入了Java堆，称为metadata）<ul>
<li>类信息、类变量、方法信息、字段信息</li>
<li>运行时常量池<ul>
<li>符号应用<ul>
<li>方法名称</li>
<li>字段名称</li>
<li>类全限定名等</li>
</ul>
</li>
<li>字面量<ul>
<li>字符串</li>
<li>常量</li>
<li>基本类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="GCROOT"><a href="#GCROOT" class="headerlink" title="GCROOT"></a>GCROOT</h5><ul>
<li>虚拟机栈中的对象</li>
<li>本地方法栈中的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>synchronize持有的对象</li>
</ul>
<h5 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h5><ul>
<li>标记—清理</li>
<li>标记—复制</li>
<li>标记—整理</li>
<li>分代收集算法</li>
</ul>
<h5 id="对象什么时候进入老年代"><a href="#对象什么时候进入老年代" class="headerlink" title="对象什么时候进入老年代"></a>对象什么时候进入老年代</h5><ul>
<li>大对象，在分配时可直接进入老年代，或年轻代可用内存不足时，通过担保机制进入老年代</li>
<li>年龄达到阈值（默认15）</li>
<li>Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，大于这些年龄的对象可以进入老年代</li>
</ul>
<h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5283abf265da573d61a311">https://juejin.im/post/5e5283abf265da573d61a311</a></p>
<h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol>
<li>装载：查找和导入Class文件</li>
<li>链接<ol>
<li>校验：校验Class文件的合法性</li>
<li>准备：给类的静态变量分配空间</li>
<li>解析：将符号引用转成直接引用</li>
</ol>
</li>
<li>初始化：对类的静态变量、静态代码块进行初始化执行操作</li>
</ol>
<h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h5><ul>
<li>BootstrapClassloader</li>
<li>ExtensionClassLoader</li>
<li>AppClassLoader</li>
</ul>
<p>双亲委托加载机制：类加载器遇到一个加载需求时，会将其委托给父加载器进行加载，如果父加载器没有加载，再由当前类加载器进行加载。方便在加载一些基础类如Object类时，不同子类加载器均加载了该类而导致各种问题（不同类加载器加载了同一个class，也视为不同类型）</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><p>过程：</p>
<ul>
<li>初始标记(STW)：可达性分析，标记根节点直接关联的对象</li>
<li>并发标记：从上个阶段对象出发，并发标记整个堆对象，参考<a href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95">三色标记法</a></li>
<li>重新标记(STW)：并发标记阶段有一些对象会修改引用关系，例如出现对象消失，需要通过增量更新方式，将删除引用记录的操作记录下来，在该步重新扫描</li>
<li>并发清理：将标记为垃圾的内存区域进行清除，因为只清除垃圾对象，所以是可以与用户线程并行执行</li>
</ul>
<p>CMS缺点：</p>
<ol>
<li>由于多个步骤与用户线程并行，所以在CPU核数较少的机器上，还是会对用户线程有明显的性能影响</li>
<li>无法处理浮动垃圾，所以无法在内存完全使用完才进行垃圾回收，必须预留部分内存。</li>
<li>前面提到CMS是标记-清除算法，所以容易造成内存碎片，在分配大内存时可能遇到有足够剩余内存但没有足够连续内存区域而导致提前FullGC的情况。CMS提供了在没有连续内存时开启内存整理的开关，但是由于需要移动内存，所以在CMS上这个步骤必须STW。</li>
</ol>
<h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><ul>
<li>G1将堆分为固定大小的region（1-32M），每个region可以被标记为年轻代或老年代，GC时以region为单位进行处理</li>
<li>同一时刻只有一个region的内存处于可分配，各个线程申请自己的buffer进行内存分配，使用完成后通过CAS继续申请，但这种方式会导致内存碎片。</li>
<li>每个region会有一个remember set，用来记录该region引用的外部对象，避免gc时扫描其他region的所有对象。在修改引用指针时，通过写屏障将该操作进行拦截，按需写入remember set</li>
</ul>
<p>当使用大内存服务器时建议使用该回收器，通过-XX:MaxGCPauseMillis可以设置每次GC停顿的最长时间，来防止需要回收大量垃圾时STW太长导致业务异常</p>
<ul>
<li>初始标记(STW)：可达性分析，标记根节点直接关联的对象</li>
<li>并发标记：从上个阶段对象出发，并发标记整个堆对象，参考<a href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95">三色标记法</a></li>
<li>最终标记(STW)：通过原始快照处理少量的并发标记阶段变化的引用关系</li>
<li>筛选回收(STW)：根据设定的停顿时长，选择收益最大的一个或多个region进行回收（因为回收过程需要移动存活的对象，所以这一步是需要STW）</li>
</ul>
<h5 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h5><p>过程：</p>
<ul>
<li>初始标记(STW)</li>
<li>并发标记</li>
<li>最终标记(STW)：SATB</li>
<li>并发清理：清理一个存活对象都没有的region</li>
<li>并发回收：<code>Shenandoah</code>并发整理通过<code>转发指针</code>来实现，在每个对象上标记其需要转发的位置，在没有重分配时，<code>转发指针</code>指向自身，当进行重分配时，<code>转发指针</code>指向重分配后的地址。<code>转发指针</code>需要使用读前屏障来实现，所以会影响GC时的吞吐，导致GC时长变长。</li>
<li>引用更新</li>
</ul>
<h5 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h5><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5b86a276f265da435c4402d4">https://juejin.im/entry/5b86a276f265da435c4402d4</a></p>
<p>JDK11引入的新垃圾收集器，可以回收超大堆（达到数T）并保证10ms以内的停顿。</p>
<blockquote>
<p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p>
</blockquote>
<ul>
<li>ZGC只有非常短暂的STW，例如根节点扫描时，但是根节点的数量是有限的，不会随着堆的大小而变化。</li>
<li>跟G1一样把堆分为了不同region，但是可以动态决定region大小（可以是N*2M），能更好处理大对象</li>
<li>通过<code>染色指针</code>来实现并发整理算法，通过占用指针中的4个bit来标记当前引用对象是否处于重分配状态，当读屏障拦截到<code>染色指针</code>时，会进行<code>自愈</code>过程，即查询记录并将指针指向新的地址，所以只会影响重分配内存后的第一次访问。并且由于<code>染色指针</code>的映射关系不记录在对象本身，所以原内存可以立刻被用来使用。</li>
</ul>
<p>过程：</p>
<ul>
<li>初始标记(STW)</li>
<li>并发标记</li>
<li>最终标记(STW)：SATB</li>
<li>并发重分配：把需要重分配的对象复制到新的region上，再维护一张转发表，将原指针染色</li>
<li>并发重映射：修改重分配的旧指针映射，但是指针在被访问时会自愈，所以这一步会在下一次gc并发标记阶段同步进行</li>
</ul>
<h5 id="CMS-与-G1-优劣对比"><a href="#CMS-与-G1-优劣对比" class="headerlink" title="CMS 与 G1 优劣对比"></a>CMS 与 G1 优劣对比</h5><p>G1优势：可以设置GC停顿时间；通过标记-整理&#x2F;复制算法实现，没有内存碎片；</p>
<p>CMS优势：只需要维护老年代到年轻代的Remember Set，但G1每个region无论是什么代都需要维护一份Remember Set，内存占用更高；都使用了读后屏障维护Remember Set，但是CMS的RSet更轻量级，性能消耗更小；G1通过原始快照方式来处理并发标记时的指针变化问题，CMS使用增量标记方式，性能消耗更小。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006824196?utm_source=tuicool&utm_medium=referral">https://segmentfault.com/a/1190000006824196?utm_source=tuicool&amp;utm_medium=referral</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23488863">https://zhuanlan.zhihu.com/p/23488863</a></p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><h5 id="IOC容器启动过程——AbstractApplicationContext-refresh"><a href="#IOC容器启动过程——AbstractApplicationContext-refresh" class="headerlink" title="IOC容器启动过程——AbstractApplicationContext.refresh()"></a>IOC容器启动过程——AbstractApplicationContext.refresh()</h5><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<ol>
<li><p>prepareRefresh() 准备工作，设置启动状态，处理配置文件占位符等</p>
</li>
<li><p>obtainFreshBeanFactory() 将需要的Bean解析成BeanDefinition并注册到BeanFactory中</p>
</li>
</ol>
<ul>
<li>refreshBeanFactory 刷新BeanFactory<ul>
<li>销毁旧的BeanFactory</li>
<li>创建一个DefaultListableBeanFactory，applicationContext持有该BeanFactory来实现后续的操作。</li>
<li>设置是否允许Bean覆盖和循环引用</li>
<li>加载Bean定义（BeanDefinition）<ul>
<li>创建XmlBeanDefinitionReader，用来读取配置XML文件</li>
<li>解析XML文件</li>
<li>解析标签，此处只整理了bean标签<ul>
<li>beanName默认使用id，如果id不存在则使用name中的第一个，如果name也没有设置，则用类名+#0</li>
<li>创建BeanDefinition</li>
<li>将bean标签中的属性赋值到BeanDefinition中</li>
<li>注册BeanDefinition<ul>
<li>注册<ul>
<li>通过beanName查找是否已经注册过</li>
<li>如果注册过，判断是否允许覆盖，如果不允许，则抛出异常，允许则直接覆盖</li>
<li>没有注册，则维护beanName和bean关联的map</li>
</ul>
</li>
<li>别名注册：维护别名与beanName的map，通过别名获取时，通过此map快速找到beanName，然后再查找对应bean</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>返回BeanFactory</li>
</ul>
<ol start="3">
<li>prepareBeanFactory(beanFactory) 准备BeanFactory</li>
</ol>
<ul>
<li>设置类加载器</li>
<li>设置默认BeanExpressionResolver</li>
<li>添加ApplicationContextAwareProcessor，此processor很常用，主要用来获取applicationContext</li>
<li>设置几个在自动注入时先忽略的几个接口</li>
<li>添加ApplicationListenerDetector，这个processor用来在初始化ApplicationListener的子类时，将其添加到监听列表中</li>
<li>手动注册一些bean</li>
</ul>
<ol start="4">
<li>postProcessBeanFactory(beanFactory) 在注册了所有Bean之后，PostBeanProcessor注册前预留的拓展点（模板方法）</li>
</ol>
<ul>
<li>AnnotationConfigServletWebServerApplicationContext（SpringBoot默认web环境时使用）在此处去扫描basePackages包下的bean并注册</li>
</ul>
<ol start="5">
<li><p>invokeBeanFactoryPostProcessors(beanFactory) 调用所有的BeanFactoryPostProcessors.postProcessBeanFactory</p>
</li>
<li><p>registerBeanPostProcessors(beanFactory) 注册ProcessBeanProcessor</p>
</li>
<li><p>initMessageSource() 处理国际化资源</p>
</li>
<li><p>initApplicationEventMulticaster() 初始化事件广播</p>
</li>
<li><p>onRefresh() 初始化bean之前的预留的拓展点（模板方法）</p>
</li>
<li><p>registerListeners() 检查和注册事件监听器</p>
</li>
<li><p>finishBeanFactoryInitialization(beanFactory) 初始化所有的非懒加载单例</p>
</li>
</ol>
<ul>
<li>合并父bean中的配置</li>
<li>如果是FactoryBean，在beanName前增加&amp;</li>
<li>getBean(String beanName)<ul>
<li>处理别名，如果传入的是别名，则获取其真实的beanName</li>
<li>判断bean是否已存在，如果存在，则直接返回（如果是FactoryBean，就返回其创建的bean）</li>
<li>初始化当前bean依赖（depend-on）的bean，递归调用getBean方法</li>
<li>createBean()<ul>
<li>检查需要创建的bean的Class已经被加载</li>
<li>准备方法覆盖（lookup-method和replace-method）</li>
<li>执行<code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>， 给某些BeanPostProcessors执行的机会来返回bean的代理，如AOP(并非所有AOP均在此处实现)</li>
<li>doCreateBean()<ul>
<li>创建实例（createBeanInstance）<ul>
<li>检查类的访问权限</li>
<li>判断构造参数类型，调用对应的构造参数<ul>
<li>如果没有使用方法覆盖，则直接通过反射调用构造参数</li>
<li>如果进行了方法覆盖，则使用CGLIB动态生成子类来实现方法覆盖</li>
</ul>
</li>
<li>返回bean的包装类型BeanWrapper</li>
</ul>
</li>
<li>Bean的装配，因为上一步只创建了实例，其中的属性没有赋值（populateBean）<ul>
<li>调用InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法</li>
<li>根据自动注入的方式（byName&#x2F;byType）调用方法，获取所有需要注入的属性（调用getBean方法）</li>
<li>调用InstantiationAwareBeanPostProcessor的postProcessProperties方法(@ Autowire之类的注解在此处通过AutowiredAnnotationBeanPostProcessor注入)</li>
<li>将获取到的属性设置到bean中</li>
</ul>
</li>
<li>初始化bean（initializeBean）<ul>
<li>三类aware回调：BeanNameAware,BeanClassLoaderAware,BeanFactoryAware</li>
<li>调用BeanPostProcessor.postProcessBeforeInitialization</li>
<li>判断bean是否实现了InitializingBean接口，如果是，调用其afterPropertiesSet方法</li>
<li>如果配置了init-method，则调用对应方法</li>
<li>调用BeanPostProcessor.postProcessAfterInitialization</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="12">
<li>finishRefresh() 广播初始化完成事件</li>
</ol>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-aop-source">https://javadoop.com/post/spring-aop-source</a></p>
<h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><h5 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h5><p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh">https://www.infoq.cn/article/jlDJQ*3wtN2PcqTDyokh</a></p>
<h6 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h6><ol>
<li><p>服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。</p>
</li>
<li><p>当服务注册中心Eureka Server检测到服务提供者因为宕机、网络原因不可用时，则在服务注册中心将服务置为DOWN状态，并把当前服务提供者状态向订阅者发布，订阅过的服务消费者更新本地缓存。</p>
</li>
<li><p>服务提供者在启动后，周期性（默认30秒）向Eureka Server发送心跳，以证明当前服务是可用状态。Eureka Server在一定的时间（默认90秒）未收到客户端的心跳，则认为服务宕机，注销该实例。</p>
</li>
</ol>
<h6 id="Eureka保护机制"><a href="#Eureka保护机制" class="headerlink" title="Eureka保护机制"></a>Eureka保护机制</h6><p>如果在一定时间内超过85%的节点没有正常心跳，那么Eureka认为客户端与注册中心的网络出现故障，Eureka进入保护模式，不再剔除任何服务哪怕长时间没有收到其心跳；该阶段仍接受新服务的注册和查询，但不会同步到其他节点上；当网络稳定后再将新注册信息同步到其他节点中。</p>
<h4 id="Spring中的各类BeanPostProcessor"><a href="#Spring中的各类BeanPostProcessor" class="headerlink" title="Spring中的各类BeanPostProcessor"></a>Spring中的各类BeanPostProcessor</h4><p><a href="/2020/04/15/spring-extend-interface/">Spring支持的扩展接口</a></p>
<h4 id="Spring-如何解决循环依赖"><a href="#Spring-如何解决循环依赖" class="headerlink" title="Spring 如何解决循环依赖"></a>Spring 如何解决循环依赖</h4><p><a href="/2020/04/26/BeanFactory-get-bean/#bean%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8">BeanFactory getBean源码分析</a></p>
<p>创建Bean的时候，每次创建完对象实例(对象A)，在进行参数设置之前，会将当前对象（还没有赋值完毕的<code>Bean</code>，也称为<code>早期引用</code>）先缓存起来；在参数赋值时，需要创建其依赖的对象，如果这个依赖的对象(对象B)正好依赖了当前需要被赋值的<code>Bean</code>，其可以从缓存中获取到其<code>早期依赖</code>，那么这个被依赖的对象(对象B)就能顺利初始化完成，随后对象A也可以被顺利初始化完成。</p>
<p>根据上述原理，一般情况下的依赖都可以解决循环依赖的问题，但是前提是只有创建完对象实例后才会被缓存，所以如果在调用构造方法时循环依赖，会导致无法创建实例，也就无法得到缓存起来的<code>早期引用</code>了。</p>
<h4 id="BeanFactory-和-ApplicationContext"><a href="#BeanFactory-和-ApplicationContext" class="headerlink" title="BeanFactory 和 ApplicationContext"></a>BeanFactory 和 ApplicationContext</h4><p><code>BeanFactory</code>实现了<code>IOC</code>容器最基本的功能，其定义了一系列<code>getBean</code>接口，通过这个方法可以获取容器所管理的<code>Bean</code>。<code>ApplicationContext</code>继承了<code>BeanFactory</code>，在<code>BeanFactory</code>的基础上扩展了一些功能，例如国际化、资源访问、事件发布等。其也是<code>Spring</code>框架的基础，提供了各种扩展能力。</p>
<p><code>ApplicationContext</code>中<code>getBean</code>接口的实现都是委托给内置的<code>BeanFactory</code>对象，例如使用最多的<code>DefaultListableBeanFactory</code>。</p>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5de3c8026fb9a07194761641">https://juejin.im/post/5de3c8026fb9a07194761641</a></p>
<p><a target="_blank" rel="noopener" href="http://www.itpub.net/2019/11/27/4449/">http://www.itpub.net/2019/11/27/4449/</a></p>
<p><a target="_blank" rel="noopener" href="https://itzones.cn/categories/rocketMQ/">https://itzones.cn/categories/rocketMQ/</a></p>
<h4 id="架构组成"><a href="#架构组成" class="headerlink" title="架构组成"></a>架构组成</h4><p><img src="/images/bb.jpeg" alt="img"></p>
<ul>
<li>NameServer：<code>NameServer</code>集群相当于精简版<code>zooKeeper</code>，用来注册<code>topic</code>与<code>broker</code>信息。<code>NameServer</code>之间不进行通讯，只与<code>broker</code>维持心跳，即<code>broker</code>定时上报其所负责的<code>topic</code>数据。</li>
<li>Broker：负责消息存储，消息收发</li>
</ul>
<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><h5 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h5><ul>
<li>commitLog：消息元数据存储文件，每个<code>broker</code>中所有元数据存储到其中。单个文件最大1G，该<code>broker</code>中的所有<code>topic</code>共用此文件，所有的元数据顺序写入，写入性能高</li>
<li>config：配置信息文件，包括一些<code>Group</code>，<code>Topic</code>以及<code>Consumer</code>消费<code>offset</code>等信息。</li>
<li>consumeQueue：消费队列文件，每个队列一个文件，相当于<code>commitLog</code>的索引。消费者按序<code>consumeQueue</code>文件，再通过每一条记录中的<code>offset</code>去<code>commitLog</code>中读取元数据。</li>
</ul>
<h5 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h5><p>客户端发送消息给<code>broker</code>时，<code>broker</code>将所有<code>topic</code>的数据写入同一个<code>commitLog</code>文件，在多个<code>topic</code>情况下顺序写入性能仍很高（对比<code>kafka</code>每个<code>topic</code>一个文件）。写入完成后，定时任务会不断扫描<code>commitLog</code>中的数据，将其写入到对应的<code>consumerQueue</code>中。</p>
<h5 id="读取过程"><a href="#读取过程" class="headerlink" title="读取过程"></a>读取过程</h5><p>客户端读取对应的<code>consumeQueue</code>文件，此过程为顺序读取可以利用操作系统<code>PageCache</code>，性能较高。通过读取到的记录中对应的元数据<code>offset</code>，可以在<code>commitLog</code>文件中找到对应的元数据。</p>
<h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5><p>在读取过程中，在通过<code>offset</code>读<code>consumeQueue</code>文件时会出现随机读，没有办法很好命中缓存，所以性能较差，主要通过Java文件映射（<code>mmap</code>）的方式，可以将文件直接映射到用户态内存地址，读写文件相当于是内存读写操作，将带来良好的性能。这种方式比较消耗内存，所以在主从模式下， 当<code>master</code>机器内存占用超过40%时，读请求将会转发给<code>salve</code>节点。</p>
<h4 id="高可用（HA）"><a href="#高可用（HA）" class="headerlink" title="高可用（HA）"></a>高可用（HA）</h4><h5 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h5><ul>
<li>单master模式：一台宕机，整个服务不可用</li>
<li>单master多slave模式：<code>master</code>宕机时不可写入，可以从<code>slave</code>读取</li>
<li>多master模式：单个<code>master</code>宕机时，该机器上面的数据不可读，如果<code>Topic</code>分布在多台<code>master</code>上，那么其余的<code>master</code>可以读写</li>
<li>多master多salve模式：某个<code>master</code>宕机，只会导致该<code>master</code>不可写入，可以从<code>salve</code>读取；如果<code>Topic</code>分布在多台<code>master</code>上，那么其余的<code>master</code>可以读写</li>
</ul>
<h5 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h5><ul>
<li>数据备份：保证一组<code>broker</code>上数据的冗余，当<code>master</code>宕机不可恢复时保证数据不丢失（或很少丢失）</li>
<li>高可用：当<code>master</code>宕机，客户端可以连接<code>salve</code>节点进行消费；生产者也可以连接<code>topic</code>对应的其他<code>broker</code>节点进行发送</li>
<li>高性能：当<code>master</code>有消息堆积时（内存使用超过40%）会将读请求转发到<code>salve</code>节点，减轻<code>master</code>节点的压力</li>
</ul>
<h5 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h5><ul>
<li>异步刷盘：发送消息时将数据写入内存，等待异步线程进行刷盘操作，有小概率宕机丢数据的可能性，但性能更高。</li>
<li>同步刷盘：主线程会等待刷盘任务完成，如果刷盘失败，则认为消息发送失败，保证数据一致性。</li>
</ul>
<h4 id="延时消息实现方案"><a href="#延时消息实现方案" class="headerlink" title="延时消息实现方案"></a>延时消息实现方案</h4><p><a target="_blank" rel="noopener" href="http://www.itpub.net/2020/01/07/5010/">http://www.itpub.net/2020/01/07/5010/</a></p>
<h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>为了防止某台master出现消息堆积而导致大量消息超时，<code>RocketMQ</code>使用了快速失败机制。通过一个定时任务，每隔10ms扫描队列中第一个节点，如果排队时间超过200ms（可配置），就会把等待时间超过该值的任务全部返回失败。而客户端将会捕获失败而进行重试，可以在其他master机器上进行重试。</p>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p><a target="_blank" rel="noopener" href="https://www.javadoop.com/post/netty-part-1">https://www.javadoop.com/post/netty-part-1</a></p>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3e11ac385c73">Hystrix技术解析</a></p>
<h4 id="信号量模式与线程池模式的区别"><a href="#信号量模式与线程池模式的区别" class="headerlink" title="信号量模式与线程池模式的区别"></a>信号量模式与线程池模式的区别</h4><img src="/images/image-20200313110844231.png" alt="image-20200313110844231" style="zoom:20%;" />

<p>信号量模式将接受请求与请求下游接口放在同一个线程中执行，即请求下游接口时不创建新的线程执行，没创建线程与上下文切换带来的开销，只通过maxConcurrentRequests参数限制最大并发数。</p>
<p>线程池模式将请求下游接口放到线程池中执行，可以异步执行多个下游接口。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5dc3a9fbf265da4d3c072eab">https://juejin.im/post/5dc3a9fbf265da4d3c072eab</a></p>
<h4 id="集群模式-1"><a href="#集群模式-1" class="headerlink" title="集群模式"></a>集群模式</h4><p>主从模式、哨兵模式、集群模式</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64">https://juejin.im/post/5b7d226a6fb9a01a1e01ff64</a></p>
<h4 id="哨兵模式架构"><a href="#哨兵模式架构" class="headerlink" title="哨兵模式架构"></a>哨兵模式架构</h4><h5 id="主节点的下线过程"><a href="#主节点的下线过程" class="headerlink" title="主节点的下线过程"></a>主节点的下线过程</h5><ol>
<li>所有哨兵节点每秒PING一次所有的主、从节点及其他哨兵节点。</li>
<li>如果一个节点超过一定时间没有相应PING，则会认为该节点主观下线</li>
<li>如果是主节点主观下线，则所有哨兵节点需要每秒检查一次该主节点是否的确进入主观下线状态</li>
<li>当一个哨兵节点认为主节点主观下线并不意味着主节点真的故障了，如果有足够数量的哨兵节点均认为该主节点是主观下线状态，则将该主节点标记为客观下线；如果没有足够数量的哨兵节点认可主节点主观下线，主节点的客观下线状态将被移除，当主节点响应了某个哨兵节点PING指令时，那么该哨兵节点对主节点的主观下线状态也会被移除。</li>
<li>哨兵节点向所有从服务器发送INFO指令，选出新的主服务器</li>
<li>将其余从节点执行新的主节点，并进行数据复制</li>
</ol>
<h5 id="选举新主节点"><a href="#选举新主节点" class="headerlink" title="选举新主节点"></a>选举新主节点</h5><h6 id="选举Sentinel-哨兵-Leader"><a href="#选举Sentinel-哨兵-Leader" class="headerlink" title="选举Sentinel(哨兵) Leader"></a>选举Sentinel(哨兵) Leader</h6><p>当需要选举主节点时，需要选举一个哨兵（Sentinel）节点为Leader。每个哨兵节点会要求其他哨兵节点选举自己为Leader，如果被请求的节点没有参与过选举，则将同意其请求，即发起请求的节点票数+1；否则不同意其请求，票数不变。</p>
<p>如果某个哨兵节点的得票数大于一半，则其成为Leader。如果没有超过一半的节点，则重新选举。</p>
<p><img src="/images/20190202175541832.png" alt="在这里插入图片描述"></p>
<h6 id="Sentinel-Leader决定主节点"><a href="#Sentinel-Leader决定主节点" class="headerlink" title="Sentinel Leader决定主节点"></a>Sentinel Leader决定主节点</h6><ol>
<li>过滤所有的故障节点</li>
<li>选择slave-priority最大的节点作为主节点，如果不存在则继续</li>
<li>选择复制偏移量最大（即已从旧主节点同步数据最多的）的节点为主节点，如果不存在则继续</li>
<li>选择runid（在节点启动时分配的随机id）最小的节点为主节点</li>
</ol>
<h4 id="Redis-Cluster-架构"><a href="#Redis-Cluster-架构" class="headerlink" title="Redis Cluster 架构"></a>Redis Cluster 架构</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zjwiOkRFvQDpKfeFL1-dUQ">https://mp.weixin.qq.com/s/zjwiOkRFvQDpKfeFL1-dUQ</a></p>
<p>一个redis集群包含2^14&#x3D;16384个哈希槽，集群中的每个节点会分配到一部分槽，如下图</p>
<p><img src="/images/54p47987806747pq8n2465o69on03o3o.jpg" alt="img"></p>
<p>集群使用公式 CRC16(key) % 16384 来计算每次请求的键 key 属于哪个槽，再通过槽对应节点配置，就可以找到key所对应的数据应该请求哪一个节点。</p>
<p>这种方式很方便进行扩容和缩容，例如：</p>
<ol>
<li><p>如果用户将新节点 D 添加到集群中，那么集群只需要将节点 A 、B、C 中的某些槽移动到节点 D 就可以了。</p>
</li>
<li><p>与此类似，如果用户要从集群中移除节点 A ，那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ，然后再移除节点 A 就可以了。</p>
</li>
</ol>
<h5 id="槽迁移过程"><a href="#槽迁移过程" class="headerlink" title="槽迁移过程"></a>槽迁移过程</h5><p>例如A节点的X槽迁移到B节点</p>
<ol>
<li>向节点 A 发送命令 CLUSTER SETSLOT X <strong><code>MIGRATING</code></strong> B，此时A节点X槽状态设置为**<code>MIGRATING</code>**</li>
<li>向节点 B 发送命令 CLUSTER SETSLOT X <strong><code>IMPORTING</code></strong> A，此时B节点X槽状态设置为**<code>IMPORTING</code>**</li>
<li>A节点中所有key开始迁移至B节点，迁移过程是<code>原子性的</code>，也就是一个key要么还在A节点中，要么已经迁移至B节点中，不会同时存在</li>
<li>此时有客户端请求属于X槽的key，如果是已存在的key，则由A处理；否则返回<code>ASK</code>指令，客户端将使用<code>ASKING</code>指令重新请求B节点；这能保证A节点中key数量只减不增，B节点key只增不减</li>
<li>当所有key都迁移完成，A、B节点清除迁移状态，B节点发送<code>UPDATE</code>指令给所有节点，通知其更新槽对应的节点信息，后续的X槽指令将全部被重定向（<code>MOVED</code>指令）到B节点</li>
</ol>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e6df710e51d4526fc74b4ec">https://juejin.im/post/5e6df710e51d4526fc74b4ec</a></p>
<h5 id="单点模式"><a href="#单点模式" class="headerlink" title="单点模式"></a>单点模式</h5><ol>
<li>通过原子命令加锁并设置失效时间，例如：<code>SET key random_value NX PX 30000</code></li>
<li>设置值时，需要设置一个随机值，通过lua脚本进行原子性解锁，保证上锁和解锁是同一个客户端</li>
</ol>
<h5 id="集群模式-2"><a href="#集群模式-2" class="headerlink" title="集群模式"></a>集群模式</h5><p>在集群模式下，如果在master节点上获取了锁，但是数据还没来得及同步到到slave节点主节点就挂了，故障转移后，从新的master节点将可以获取到一个新的锁，出现了一把锁被两个线程持有的问题。</p>
<h5 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h5><p>上锁：在集群模式下，即有N个节点的情况下，通过一个统一key+随机值的方式，向N个节点获取锁。只要有N&#x2F;2+1个节点加锁成功，则视为获取锁成功，否则需要进行解锁。</p>
<p>解锁：依次向每个节点发起解锁操作，即便这个节点上没有上锁成功。</p>
<p>风险点：当某个节点上锁成功，但是故障重启后，可能会丢失数据从而导致其他客户端可以重复上锁成功。例如三个节点中有两个加锁成功一个加锁失败，加锁成功数大于等于N&#x2F;2+1，所以视为上锁成功。此时加锁成功的一个节点故障重启并丢失了数据，此时如果有客户端申请加锁，将可以获取锁成功。</p>
<h4 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h4><p><a target="_blank" rel="noopener" href="https://zackku.com/redis-rdb-aof/">https://zackku.com/redis-rdb-aof/</a></p>
<h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>定时把数据的快照保存到文件中，由于是某个时间点的快照，所以可能会丢数据，但是持久化和加载性能更高，文件数据更小。</p>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>将每次的操作记录写入到缓冲区，根据策略（每次刷盘、每秒刷盘、等操作系统自动刷盘）将记录追加到文件上。</p>
<p>由于记录每次操作，日志文件冗余，加载速度会很慢，所以可以开启<code>日志重写</code>，例如将多次<code>INCR</code>操作合并成一次<code>SET</code>操作。</p>
<p><code>AOF</code>相对于<code>RDB</code>可靠性更高，但是默认刷盘策略为一秒一次，仍不能保证数据绝对安全；AOF记录的是操作日志，所以可读性更高，即使文件被部分破坏，也容易恢复到某个数据节点；但是存储的文件更大，写入和加载性能效率低于<code>RDB</code></p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><table>
<thead>
<tr>
<th>Redis</th>
<th>底层数据结构</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>当存储值为整数时，使用int<br />当存储值为字符串且小于32字节，使用embstr，即优化后的<code>SDS</code><br />当存储值为字符串且大于32字节，使用raw，即SDS</td>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021509861"><code>SDS</code></a>为包装后的char数组<br /><br />浮点数也通过char数组，需要计算时转成浮点数计算，计算完转成char数组保存<br />SDS中最大只能保存512M数据</td>
</tr>
<tr>
<td>list</td>
<td>3.2版本前&amp;数据较少时，使用<em>ziplist</em><br />3.2版本前&amp;数据较多时，使用<em>linkedlist</em><br />3.2版本后，使用<em>quicklist</em></td>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021576621"><code>ziplist</code></a><br /><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021562338"><code>linkedlist</code></a><br /><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021585652"><code>quicklist</code></a></td>
</tr>
<tr>
<td>hash</td>
<td><code>hashtable</code></td>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021604679"><code>hashtable</code></a></td>
</tr>
<tr>
<td>set</td>
<td>当所有元素为整数&amp;个数小于512时，使用<code>intset</code><br />其他情况，使用<code>hashtable</code></td>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021596163"><code>intset</code></a></td>
</tr>
<tr>
<td>zset</td>
<td>当元素较少时，使用<em>ziplist</em> + <code>hashtable</code><br />当元素较多时，使用<code>skiplist</code> + <code>hashtable</code></td>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021618668"><code>skiplist</code></a><br />使用<code>skiplist</code> + <code>hashtable</code>是为了利用查询时<code>hashtable</code>O(1)时间复杂度和排序时<code>skiplist</code>O(logn)时间复杂度的优势</td>
</tr>
</tbody></table>
<h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><ul>
<li><p>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</p>
</li>
<li><p>allkeys-lru：从所有key中使用LRU算法进行淘汰</p>
</li>
<li><p>volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</p>
</li>
<li><p>allkeys-random：从所有key中随机淘汰数据</p>
</li>
<li><p>volatile-random：从设置了过期时间的key中随机淘汰</p>
</li>
<li><p>volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</p>
</li>
</ul>
<h4 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h4><h5 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h5><p>可以操作一个值中的二级制位，可以用来实现布隆过滤器</p>
<h5 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h5><p>可以存储位置，并通过目标位置的距离查询指定距离范围内的数据，例如实现附近的人。</p>
<h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><p>适合用来统计一个集合中不重复的元素个数，但不要求数据完全准确的情况，例如访问UV等。</p>
<p>一亿个统计数据约只占12M内存。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p><a target="_blank" rel="noopener" href="https://draveness.me/mysql-innodb">https://draveness.me/mysql-innodb</a></p>
<p>MySQL索引背后的数据结构及算法原理（包含B树和B+树原理）<a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<h4 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h4><p><a target="_blank" rel="noopener" href="https://github.com/hedengcheng/tech/blob/master/database/MySQL/MySQL%20%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90.pdf">MySQL加锁分析</a></p>
<h5 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h5><ul>
<li><p>互斥锁、共享锁、意向互斥锁、意象共享锁</p>
</li>
<li><p>什么是意象锁</p>
</li>
</ul>
<blockquote>
<p>如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。</p>
</blockquote>
<h5 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h5><h6 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h6><ol>
<li><p>如果where 条件中包含主键索引或其他索引作为过滤条件，那么将在B+树中找到对应记录并上锁，即为Record Lock；</p>
</li>
<li><p>如果没有索引，那么只能进行锁表。</p>
</li>
</ol>
<h6 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h6><p>当where条件中存在范围条件时（必须有索引，否则仍为表锁），例如where id between 10 and 20，将会上Gap Lock。</p>
<h6 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h6><p>Next-Key Lock算法，锁定的不是单个值，而是一个范围（GAP）。上面索引值有1，3，5，8，11，其记录的GAP的区间如下：是一个<strong>左开右闭</strong>的空间</p>
<p>（-∞,1]，(1,3]，(3,5]，(5,8]，(8,11]，(11,+∞）</p>
<p><code>Next-Key Lock</code>是<code>Record Lock</code>和<code>Gap Lock</code>的组合，即锁住范围的同时锁住区间，在RR(REPEATABLE-READ)隔离级别下, <code>SELECT ... FOR UPDATE</code>使用<code>Next-Key Lock</code>, 即<code>Record Lock</code> + <code>Gap Lock</code>.</p>
<p>在一些场景下<code>Next-Key Lock</code>会退化</p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>退化成的锁类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>使用<code>unique index</code>精确匹配(&#x3D;), 且记录存在</td>
<td>Record Lock</td>
</tr>
<tr>
<td>使用<code>unique index</code>精确匹配(&#x3D;), 且记录不存在</td>
<td>Gap Lock</td>
</tr>
<tr>
<td>使用<code>unique index</code>范围匹配(&lt;和&gt;)</td>
<td><code>Record Lock</code> + <code>Gap Lock</code> 且 锁上界不锁下界</td>
</tr>
</tbody></table>
<h5 id="Gap-Lock-与-Next-Key-Lock"><a href="#Gap-Lock-与-Next-Key-Lock" class="headerlink" title="Gap Lock 与 Next-Key Lock"></a>Gap Lock 与 Next-Key Lock</h5><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/innodb-record-level-locks.html">https://docs.oracle.com/cd/E17952_01/mysql-5.0-en/innodb-record-level-locks.html</a></p>
<p>带翻译版：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1447138">https://cloud.tencent.com/developer/article/1447138</a></p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>在多个SQL以不同顺序申请锁时，可能会产生死锁，例如:</p>
<blockquote>
<p>使用索引A（非主键）进行更新时，如果恰巧有其他sql通过主键更新A字段时，将有可能死锁。因为通过非主键更新时，会先将A（辅助索引）上锁，再找到其主键上锁；通过主键更新时，会先对主键上锁，如果发现需要更新的字段为辅助索引（如A索引）时，再将辅助索引上锁，此时就会导致死锁。</p>
</blockquote>
<h4 id="单表理想性能计算"><a href="#单表理想性能计算" class="headerlink" title="单表理想性能计算"></a>单表理想性能计算</h4><ul>
<li>希望btree的高度h&lt;&#x3D;3，即最多通过两次IO可以查询所有数据（根节点常驻内存）</li>
<li>InnoDB中主键默认为64位即8b，索引为6b，合计一条记录需要14b，MySQL中一个节点占用一页，一页大小为16k，所以每个节点最多16kb&#x2F;14b&#x3D;1170条记录</li>
<li>h&#x3D;3时，索引占用前两层，所以一共1170*1170条内页索引（不包含叶子节点的节点数）</li>
<li>假设每条记录为1k，所以叶子节点中每一个节点约为16条记录，合计1170*1170*16约等于两千万，此时单表占用空间约为1170*1170*16&#x2F;1024&#x2F;1024≈20G</li>
<li>坊间传的MySQL数据量达到两千万后性能下降的原因大致是这样的，但是是按每条记录1k计算的，所以仅供参考，如果单行记录远小于这个值的，不会受两千万数量的影响</li>
<li>例如辅助索引，叶子节点存储的数据域是主键（InnoDB），所以每一行占用的空间为16b（key 8b，主键8b），那么每个叶子节点最多容纳16k&#x2F;16b&#x3D;1000个节点，此时整棵树最多可容纳1170*1170*1000约等于13亿行</li>
<li>所以可以认为，当表数据量小于20G且行数不大于13亿时，一般不会出现太大性能瓶颈</li>
</ul>
<h4 id="索引（InnoDB）"><a href="#索引（InnoDB）" class="headerlink" title="索引（InnoDB）"></a>索引（InnoDB）</h4><ul>
<li>聚集索引：存放着一条行记录的全部信息</li>
<li>辅助索引：包含索引列和一个用于查找对应行记录的『书签』</li>
</ul>
<h5 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h5><p>如果在辅助索引中（例如(user_id,user_name)），不包含所要查询的字段，例如<code> select user_name,sex from tb_user where user_id = xxx</code>语句中，需要查询user_name和sex，但是在该索引中不包含sex字段，所以需要通过辅助索引找到主键，再通过聚集索引找到完整数据才能获取到sex字段，这个过程即为<code>回表</code> 。</p>
<h5 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h5><p>上文<code>回表</code>可以看出，回表操作需要额外通过主键索引找到完整数据的过程，比不回表的操作多了一次IO，所以可以尽量避免此类消耗。例如将常用的查询字段放入索引中，若索引中的字段涵盖了要查询的所有字段，即为<code>索引覆盖</code>。不过会增大索引的空间造成浪费，通过空间换时间，需要根据业务场景选择。 </p>
<h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p><code>索引下推</code>可以在范围查询或like查询情况下，减少回表操作。</p>
<p>例如有a,b两个字段，建立 <code>(a,b)</code> 联合索引，执行 <code>select * where a &gt; 0 and b &gt;0</code></p>
<p>正常情况下，只能用到a字段的索引，因为B+树中只能通过前缀匹配范围查询。通过筛选<code> a&gt;0</code>条件后，进行回表操作，再筛选出 <code>b&gt;0</code>的记录</p>
<p>可以发现，这种方式回表的数据较多，其实可以做一次优化，在筛选完<code>a&gt;0</code>后，再进行一次<code>b&gt;0</code>筛选，这样回表的数据就少多了，这种优化方式成为<code>索引下推</code>，MySQL中默认开启。</p>
<h5 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h5><ol>
<li>最左前缀匹配</li>
<li>不要使用函数</li>
<li>用区分度大的字段作为索引</li>
<li>减少<code>回表</code>操作，请求量大的<code>SQL</code>可以考虑进行<code>索引覆盖</code></li>
<li>尽量减少使用排序，如果要使用，尽量保证走索引；如果不走索引尽量保证在内存中排序；尽量使用<code>LIMIT</code>，因为<code>LIMIT</code>能尽可能保证进行内存排序而不是<code>文件排序</code>，参见<a href="#LIMIT%E4%BC%98%E5%8C%96">LIMIT优化</a></li>
</ol>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cchust/p/5304594.html">MySQL排序原理与案例分析</a></p>
<p>计划任务中出现<code>Using filesort</code>表示需要额外排序，但不一定是文件排序，也有可能是内存排序</p>
<h5 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h5><ol>
<li>查询出满足<code>where</code>条件的记录</li>
<li>对于每条记录，将主键+排序key取出，放入<code>sort buffer</code>，例如(id+key)</li>
<li>如果<code>sort buffer</code>能存放下所有的记录，则在内存中使用<code>快速排序</code>；如果放不下，就需要放入文件中，使用<code>归并排序</code></li>
<li>排序完后，如果需要<code>limit</code>则进行过滤；如果需要<a href="#%E5%9B%9E%E8%A1%A8">回表</a>，则执行回表</li>
<li>将数据返回给客户端</li>
</ol>
<h5 id="LIMIT优化"><a href="#LIMIT优化" class="headerlink" title="LIMIT优化"></a>LIMIT优化</h5><p>例如<code>Order by limit M,N</code>，虽然所有元素都要参与排序，但是在<code>sort buffer</code>中只需要能放下N+M个元素即可在内存中使用<code>堆排序</code>，而不需要进行文件排序，减少IO提高性能。</p>
<h4 id="事务特性-ACID"><a href="#事务特性-ACID" class="headerlink" title="事务特性 ACID"></a>事务特性 ACID</h4><ul>
<li>原子性(Atomicity)：事务是一个不可再分割的工作单元</li>
<li>一致性(Consistency)：事务不能破坏关系数据的完整性以及业务逻辑上的一致性</li>
<li>隔离性(Isolation)：事务之间是隔离的，一个事务不应该影响其它事务运行效果</li>
<li>持久性(Durability)：事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><strong>此处注意甄别数据库规范与InnoDB具体实现之间的差异，此处指InnoDB的具体实现</strong></p>
<ul>
<li>未提交读(READ UNCOMMIT)：存在脏读问题</li>
<li>提交读(READ COMMIT)：解决脏读问题，存在不可重复读和幻读问题</li>
<li>重复读(REPEATABLE READ)：解决不可重复读问题和幻读，通过MVCC解决不可重复读，通过gap lock解决幻读</li>
<li>串行(SERIALIZABLE)：从MVCC退化到基于锁的并发控制</li>
</ul>
<h4 id="不可重复读和幻读"><a href="#不可重复读和幻读" class="headerlink" title="不可重复读和幻读"></a>不可重复读和幻读</h4><p>不可重复读是指在一个事务中，已加锁的记录第二次读取时与之前的内容不同，但数量不变，即可能被<code>update</code></p>
<p>幻读是指在一个事务中，已加锁的数据第二次读取时结果集数量不同，即可能被<code>insert</code>或<code>delete</code>。官方链接：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/itcomputer/articles/5133254.html">https://www.cnblogs.com/itcomputer/articles/5133254.html</a></p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p><a target="_blank" rel="noopener" href="https://chenjiayang.me/2019/06/22/mysql-innodb-mvcc/">https://chenjiayang.me/2019/06/22/mysql-innodb-mvcc/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/naci/p/3753644.html?utm_source=tuicool&utm_medium=referra">https://www.cnblogs.com/naci/p/3753644.html?utm_source=tuicool&amp;utm_medium=referra</a></p>
<p><code>MVCC (Multiversion Concurrency Control)</code> 中文全程叫<strong>多版本并发控制</strong>，是现代数据库（包括 <code>MySQL</code>、<code>Oracle</code>、<code>PostgreSQL</code> 等）引擎实现中常用的处理读写冲突的手段，<strong>目的在于提高数据库高并发场景下的吞吐性能</strong>。用来实现<code>InnoDB</code>中的RC和RR级别。</p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>在每一行数据中，增加了两个隐藏字段，分别是<code>DATA_TRX_ID</code>和<code>DATA_ROLL_PTR</code>，<code>DATA_TRX_ID</code>表示更新这条记录的事务id，事务id为每次开启事务时分配的id，保证先开启事务的事务id小于后开启的事务。<code>DATA_ROLL_PTR</code>为指向指向<code>undo log</code>中该行之前版本的指针。</p>
<p>在每次更新，把需要更新的行数据原样拷贝到<code>undo log</code>中；再修改表中改行的值，并把<code>DATA_TRX_ID</code>的值设置为当前修改事务id、<code>DATA_ROLL_PTR</code>设置为<code>undo log</code>行所在的地址；</p>
<p>插入操作仅需要把新插入的行中<code>DATA_TRX_ID</code>设置为当前事务id即可；</p>
<p>删除操作与更新操作的差别为需要修改需要删除行的删除标记为已删除；</p>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><p>在执行<code>select</code>操作时，将当前系统中所有的活跃事务id拷贝到一个列表中，生成一个<code>ReadView</code>。其中的事务id称为<code>m_ids</code>。</p>
<p>在RC中，每一个<code>select</code>均会生成一个<code>ReadView</code>；RR中，只在每个事务的第一次<code>select</code>生成<code>ReadView</code>。</p>
<ol>
<li>如果被访问版本的 <code>trx_id</code> 小于 <code>m_ids</code> 中的最小值，说明生成该版本的事务在 <code>ReadView</code> 生成前就已经提交了，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的 <code>trx_id</code> 大于 <code>m_ids</code> 列表中的最大值，说明生成该版本的事务在生成 <code>ReadView</code> 后才生成，所以该版本不可以被当前事务访问。需要根据 <code>Undo Log</code> 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。</li>
<li>如果被访问版本的 <code>trx_id</code> 属性值在 <code>m_ids</code> 列表中最大值和最小值之间（包含），那就需要判断一下 <code>trx_id</code> 的值是不是在 <code>m_ids</code> 列表中。如果在，说明创建 <code>ReadView</code> 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 <code>DB_TRX_ID</code> 再从头计算一次可见性；如果不在，说明创建 <code>ReadView</code> 时生成该版本的事务已经被提交，该版本可以被访问。</li>
<li>此时经过一系列判断我们已经得到了这条记录相对 <code>ReadView</code> 来说的可见结果。此时，如果这条记录的 <code>delete_flag</code> 为 <code>true</code>，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。</li>
</ol>
<h4 id="主从复制与读写分离"><a href="#主从复制与读写分离" class="headerlink" title="主从复制与读写分离"></a>主从复制与读写分离</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>数据写操作走主库，读操作走从库，实现读写分离。所有写操作记录写入<code>binlog</code>，从库通过一个<code>IO线程</code>将主库<code>binlog</code>同步至本地，再将内容写入<code>relay log</code>。从库中的<code>SQL 线程</code>将读取<code>relay log</code>将其顺序执行，实现数据变更从主库同步到从库的过程。</p>
<h5 id="数据延迟"><a href="#数据延迟" class="headerlink" title="数据延迟"></a>数据延迟</h5><p>主库与从库间的数据延迟的可能原因</p>
<ol>
<li><code>binlog</code>从主库同步到从库是异步的，外加需要同步完成后再重新执行<code>binlog</code>，天然存在延迟</li>
<li>主库的写操作是可以并发的，但是从库在同步时的变更操作是单线程的</li>
<li>主库执行完变更后宕机，<code>binlog</code>没来得及同步到从库</li>
</ol>
<h5 id="解决（缓解）方案"><a href="#解决（缓解）方案" class="headerlink" title="解决（缓解）方案"></a>解决（缓解）方案</h5><ol>
<li><code>半同步复制</code>：主库在提交完事务后，不直接返回给客户端，而是等待至少一个从库接受并写入到<code>relay log</code>后才返回。保障了数据的安全性，但是会导致用户请求的延迟。</li>
<li><code>并行复制</code>：从库可以开启多个线程读取<code>relay log</code>中不同库的日志，实现库级别的并行</li>
<li>在特殊业务场景下，读操作直连主库，保证数据的可见性。</li>
</ol>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/k0zAExTvMsrugCaNJxs7hQ">Zookeeper的ZAB协议</a></p>
<h4 id="ZK的缺陷"><a href="#ZK的缺陷" class="headerlink" title="ZK的缺陷"></a>ZK的缺陷</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/oO9IrTVb4OjPEPzM71wHNQ">阿里为什么不用 ZooKeeper 做服务发现</a></p>
<ol>
<li>ZK追求CP而不是AP，导致脑裂时，该机房的ZK处于不可以状态，导致通过ZK实现的服务发现的集群在该机房的机器虽然网络畅通，但不可调用。</li>
<li>注册中心不应该因为自身的问题而影响服务之间本身的可连通性。即服务应该仅在上下线、扩缩容等必要时才依赖注册中心，当ZK宕机时，不应该影响已启动业务之间的互相调用。</li>
<li>由于ZK写操作不可扩展，无法通过增加节点解决写压力，如果微服务过多，外加每个服务都要进行健康检查，ZK将会不堪重负。即使通过业务隔离划分多个ZK集群，但不能保证不同业务之间永远不会互相调用。</li>
<li>一般的服务健康检查都是依赖ZK对TCP长链接的活性检查，但这种方式不够灵活，TCP活跃不代表服务健康</li>
</ol>
<p>总结：ZK适合在不需要高TPS支持的业务场景下处理分布式锁、分布式选主、主备切换等；如果在高TPS链路上、大规模数据存取、服务发现、健康检查等方便并不适合。</p>
<h3 id="HBase设计原理"><a href="#HBase设计原理" class="headerlink" title="HBase设计原理"></a>HBase设计原理</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laoqing/p/12091471.html">https://www.cnblogs.com/laoqing/p/12091471.html</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019959411">https://segmentfault.com/a/1190000019959411</a></p>
<h4 id="架构组成-1"><a href="#架构组成-1" class="headerlink" title="架构组成"></a>架构组成</h4><ul>
<li><p>HMaster：负责<code>Region</code>的分配；表结构创建修改等操作；通过<code>ZK</code>监听管理<code>RegionServer</code></p>
</li>
<li><p>RegionServer：管理<code>Region</code>，每个<code>RegionServer</code>可管理1000个<code>Region</code>；处理<code>Region</code>的读写请求；切分过大的<code>Region</code></p>
</li>
<li><p>Region：<code>Table</code>中的数据根据<code>rowKey</code>的范围被水平分割存放在多个<code>Region</code>上</p>
</li>
</ul>
<h4 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li>MetaTable：<code>HBase</code>中的一张特殊的表，用来存放<code>RowKey</code>与<code>RegionServer</code>的关系</li>
<li>WAL：<code>Write Ahead Log </code>是<code>HDFS</code>中的一个文件，也称为<code>HLog</code>。同一个<code>RegionServer</code>共用同一个<code>WAL</code>文件，所有写操作信息会被优先写入<code>WAL</code>文件</li>
<li>BlockCache：读缓存</li>
<li>MemStore：写缓存，写操作被写入<code>MemStore</code>后即视为写入成功，后续根据一定策略进行刷盘（<code>flush</code>如HDFS）（类似与操作系统中的<code>PageCache</code>）。每个<code>Column Family</code>都会对应一个<code>MemStore</code></li>
<li>HFile：在HDFS中存储的数据，以KV方式存储，相同的数据会有多个版本共存</li>
</ul>
<p><img src="/images/1200756-20191224143040070-1153407888.png" alt="img"></p>
<h5 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h5><ol>
<li>新数据被写入<code>WAL</code></li>
<li>新数据写入<code>MemStore</code></li>
<li>写入成功</li>
</ol>
<p>由于<code>WAL</code>文件写入采用<code>append</code>方式，所以为顺序写入，性能很高。在成功写入<code>WAL</code>后再写入<code>MemStore</code>保证机器宕机掉电导致<code>MemStore</code>中数据丢失，也可以通过<code>WAL</code>文件恢复丢失数据。</p>
<p>当<code>MemStore</code>中积累一定数据后，每个<code>MemStore</code>会往<code>HDFS</code>上写入一个新的<code>HFile</code>，当一个<code>MemStore</code>满了，内存中的所有<code>MemStore</code>都会被<code>flush</code>到<code>HDFS</code>中</p>
<h5 id="压缩（Compaction）"><a href="#压缩（Compaction）" class="headerlink" title="压缩（Compaction）"></a>压缩（Compaction）</h5><p>每次<code>MemStore</code>刷盘操作都会生成新的<code>HFile</code>，过多<code>HFile</code>会导致读性能问题，需要通过压缩来解决</p>
<ul>
<li>Minor Compaction：选取一些小的<code>HFile</code>将其合并成较大的<code>HFile</code>，这个过程不会处理已经删除或失效的数据。</li>
<li>Major Compaction：将单个<code>Region</code>中的所有<code>HFile</code>合并成一个大的<code>HFile</code>（每个<code>Column Family</code>仍为独立的<code>HFile</code>），由于<code>Major Compaction</code>对机器的IO等影响较大，所以一般在低峰期计划执行。</li>
</ul>
<h5 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h5><p>一张表刚开始只有一个<code>region</code>，当数据变多变大时，它会分裂成两个<code>region</code>，各自包含原来的一半数据。出于负载均衡考虑，<code>HMaster</code>会将新生成的region迁移到其他<code>HRegionServer</code>中，此时的迁移只是逻辑上的，也就是说只是把新的<code>region</code>交给其他<code>HRegionServer</code>管理，但数据仍在原处，所以此时<code>HRegionServer</code>需要访问不在本地（本机）的数据而影响性能。等到下一次<code>Major Compaction</code>可以将数据移到<code>HRegionServer</code>附近存储解决问题。</p>
<h5 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h5><ol>
<li>客户端从<code>ZK</code>处查询<code>MetaTable</code>所在的<code>HRegionServer</code></li>
<li>查询对应<code>HRegionServer</code>获取<code>MetaTable</code>，根据<code>MetaTable</code>确定<code>RowKey</code>所在<code>HRegionServer</code></li>
<li>访问<code>HRegionServer</code>查询数据</li>
</ol>
<p>在查询<code>HRegionServer</code>的具体查询过程如下：</p>
<ol>
<li>从<code>BlockCache</code>中查询</li>
<li>从<code>MemStore</code>中查询</li>
<li>查询<code>HFile</code>，由于查询<code>HFile</code>涉及到磁盘IO会影响性能，所以会通过<code>BlockCache</code>中的索引和布隆过滤器进行查询优化。</li>
</ol>
<p>由于每一个<code>RowKey</code>存在多个历史版本，所以一次读操作可能需要查询多次，而每个版本数据可能会在不同<code>HFile</code>上，会影响性能，这被称为<code>读放大</code>。</p>
<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>当某个<code>RegionServer</code>宕机时，该节点与<code>ZK</code>的链接会断开，此时<code>HMaster</code>将会监听到此事件，<code>HMaster</code>开始自动进行故障恢复：</p>
<ol>
<li>把原来由该<code>RegionServer</code>管理的<code>region</code>分配给其他健康的<code>RegionServer</code></li>
<li>有些数据还在<code>MemStore</code>中并没有刷盘，此时需要将<code>WAL</code>日志按<code>Region</code>进行切分</li>
<li>每个<code>Region</code>执行日志回放进行数据恢复</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>数据在单机上过大时，将自动进行分裂而实现负载均衡，可以通过水平扩展存储海量数据</li>
<li>使用<code>HDFS</code>作为底层数据存储，保障数据安全性</li>
<li>使用<code>WAL</code>进行数据恢复保证高可用</li>
<li>离线计算友好</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>故障恢复很慢</li>
<li><code>Major Compaction</code>会占用大量I&#x2F;O资源</li>
<li>不支持二级索引</li>
</ul>
<h3 id="MongoDB-ElasticSearch设计原理"><a href="#MongoDB-ElasticSearch设计原理" class="headerlink" title="MongoDB&#x2F;ElasticSearch设计原理"></a>MongoDB&#x2F;ElasticSearch设计原理</h3><h2 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h2><ul>
<li>细数JDK里的设计模式 <a target="_blank" rel="noopener" href="http://blog.jobbole.com/62314/">http://blog.jobbole.com/62314/</a></li>
<li>模板方法</li>
<li>工厂</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="TCP-IP-四层协议"><a href="#TCP-IP-四层协议" class="headerlink" title="TCP&#x2F;IP 四层协议"></a>TCP&#x2F;IP 四层协议</h3><ol>
<li>网络访问层</li>
<li>网络层：IP、ARP</li>
<li>传输层：TCP、UDP</li>
<li>应用层：HTTP、FTP、SMTP</li>
</ol>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86426969">https://zhuanlan.zhihu.com/p/86426969</a></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手是指服务器与客户端建立一个TCP链接一共需要通讯三次，目的是为了互相确认彼此的接受和发送能力均正常。</p>
<table>
<thead>
<tr>
<th>次序</th>
<th>发包方向</th>
<th>发送信息</th>
<th>能力确认</th>
<th>是否可携带数据</th>
</tr>
</thead>
<tbody><tr>
<td>第一次</td>
<td>客户端-&gt;服务端</td>
<td>SYN&#x3D;1,seq&#x3D;x</td>
<td>客户端发送能力正常</td>
<td>否</td>
</tr>
<tr>
<td>第二次</td>
<td>服务端-&gt;客户端</td>
<td>SYN&#x3D;1,ACK&#x3D;1,ack&#x3D;x+1,seq&#x3D;y</td>
<td>服务端发送能力、接受能力正常</td>
<td>否</td>
</tr>
<tr>
<td>第三次</td>
<td>客户端-&gt;服务端</td>
<td>ACK&#x3D;1,ack&#x3D;y+1,seq&#x3D;x+1</td>
<td>客户端接受能力正常</td>
<td>是</td>
</tr>
</tbody></table>
<h5 id="半连接队列和全连接队列"><a href="#半连接队列和全连接队列" class="headerlink" title="半连接队列和全连接队列"></a>半连接队列和全连接队列</h5><p>服务器端在收到客户端发来的第一次<code>SYN</code>报文后，会处于<code>SYN_RCVD</code>状态，服务器会将这种状态的连接放入队列中，称为<code>半连接队列</code>。在这个队列中的连接如果等待一段时间没有收到客户端的确认包，将会进行重传直到达到最大重传次数，然后会被从<code>半连接队列</code>中移除。</p>
<p>针对这种机制，有可能受到<code>SYN攻击</code>，即客户端发起大量<code>SYN</code>请求，导致<code>半连接队列</code>被占满并且不断进行重试，最终导致网络瘫痪。</p>
<p>完成<code>三次握手</code>的连接，将会放入<code>全连接队列</code>中。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>断开连接需要四次通讯，因为断开连接需要连接双方各主动发起一次结束报文，证明发起方不再向对方发送数据了，并且每一次发起对方均需要响应，所以一共有四次通讯。</p>
<table>
<thead>
<tr>
<th>次序</th>
<th>发包方向</th>
<th>发送信息</th>
<th>当前状态</th>
</tr>
</thead>
<tbody><tr>
<td>第一次</td>
<td>客户端-&gt;服务端</td>
<td>FIN&#x3D;1,seq&#x3D;i</td>
<td>客户端停止发送数据</td>
</tr>
<tr>
<td>第二次</td>
<td>服务端-&gt;客户端</td>
<td>ACK&#x3D;1,ack&#x3D;i+1,seq&#x3D;j</td>
<td>服务端停止接受数据</td>
</tr>
<tr>
<td>第三次</td>
<td>服务端-&gt;客户端</td>
<td>FIN&#x3D;1,ACK&#x3D;1,ack&#x3D;i+1,seq&#x3D;k</td>
<td>服务端停止发送数据</td>
</tr>
<tr>
<td>第四次</td>
<td>客户端-&gt;服务端</td>
<td>ACK&#x3D;1,ack&#x3D;k+1,seq&#x3D;i+1</td>
<td>客户端等待2MSL后关闭并进入CLOSE<br />服务端接受后直接进入CLOSE</td>
</tr>
</tbody></table>
<h5 id="第四次接受到响应报文后为何需要等待2MSL才能进入CLOSED"><a href="#第四次接受到响应报文后为何需要等待2MSL才能进入CLOSED" class="headerlink" title="第四次接受到响应报文后为何需要等待2MSL才能进入CLOSED"></a>第四次接受到响应报文后为何需要等待2MSL才能进入CLOSED</h5><p><code>MSL</code>（Maximum Segment Lifetime）表示一个报文在网络传输时最大生命周期，如果超过这个时间，就算被接受到，报文也会被丢弃。</p>
<p>第四次挥手时，客户端的<code>ACK</code>报文在传输中可能会丢失，服务器会要求客户端进行重传，如果客户端立即进入<code>CLOSED</code>，将没有能力响应，从而导致服务端无法正常<code>CLOSED</code>。等待2MSL表示服务端已经无需客户端进行重传了，则可以关闭。</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP1-0-与-HTTP1-1的区别"><a href="#HTTP1-0-与-HTTP1-1的区别" class="headerlink" title="HTTP1.0 与 HTTP1.1的区别"></a>HTTP1.0 与 HTTP1.1的区别</h4><ol>
<li>更多的缓存策略，如If-Unmodified-Since, If-Match, If-None-Match</li>
<li>支持客户端请求部分数据，可以实现断点续传</li>
<li>请求头中增加了<code>host</code>字段</li>
<li>支持长链接和流水线，提高性能</li>
</ol>
<h4 id="HTTP1-1-与-HTTP2-0的区别"><a href="#HTTP1-1-与-HTTP2-0的区别" class="headerlink" title="HTTP1.1 与 HTTP2.0的区别"></a>HTTP1.1 与 HTTP2.0的区别</h4><ol>
<li>多路复用：降低服务端连接压力，降低传输延迟</li>
<li>首部压缩：避免<code>header</code>中数据重复传输</li>
<li>服务端推送：服务端可以将资源主动推送给客户端，提高加载效率</li>
</ol>
<h4 id="HTTP-与-HTTPS的区别"><a href="#HTTP-与-HTTPS的区别" class="headerlink" title="HTTP 与 HTTPS的区别"></a>HTTP 与 HTTPS的区别</h4><p><code>HTTP</code>数据传输完全明文，容易被抓包和劫持；<code>HTTPS</code>使用<code>TLS</code>（<code>SSL</code>的新版本）来保证安全传输，数据加密传输。</p>
<p>HTTPS过程：</p>
<ol>
<li>在握手过程中，客户端向服务端请求证书，服务端返回证书及公钥</li>
<li>客户端收到证书后向证书签发机构验证</li>
<li>客户端生成对称秘钥，用服务端公钥加密后传输给服务端，后续请求通过该秘钥加密通信</li>
</ol>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>二叉搜索树</li>
<li>平衡树</li>
<li>平衡查找树——2-3树 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html">https://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html</a></li>
<li>红黑树（2-3树的二叉实现）：高度为lgN <a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html">https://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html</a></li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="HashedWheelTimer"><a href="#HashedWheelTimer" class="headerlink" title="HashedWheelTimer"></a>HashedWheelTimer</h4><p><a target="_blank" rel="noopener" href="https://www.javadoop.com/post/HashedWheelTimer">https://www.javadoop.com/post/HashedWheelTimer</a></p>
<p><img src="/images/4-20200409100840548.png" alt="4"></p>
<p>将一个轮盘分为512格，每一格跨度100ms。每个任务根据执行时间放入对应的格子里，并计算其轮次。每次循环到下一个格子时，先计算距离当前格子的执行开始时间，如果还没到，则sleep到目标时间，然后按顺序执行这个格子中轮次为0的所有任务，轮次不为0的任务全部自减；如果已经超过这个格子的deadline，即开始时间+100ms，则直接跳过这次执行。</p>
<p>例如1000ms后执行的任务，需要放到(1000&#x2F;100)%512&#x3D;10号格子中，轮次为0；513000ms后执行的任务，需要放到(513000&#x2F;100)%512&#x3D;10，轮次为1；</p>
<p>可以发现1000ms和513000ms后执行的任务放在了同一个队列中，但是轮次不同，第一次执行当10号格子时，100ms任务轮次为0，正常执行；513000ms任务轮次自减成0，下一次轮到的时候就可以执行了。</p>
<h5 id="如果上一个格子占用了过多时间怎么办"><a href="#如果上一个格子占用了过多时间怎么办" class="headerlink" title="如果上一个格子占用了过多时间怎么办"></a>如果上一个格子占用了过多时间怎么办</h5><p>正常情况下，每个格子只有100ms的执行窗口期，但是在执行过程中不会判断是否执行超时，只有全部执行完，走到下一个格子时，会判断是否超过当前格子的deadline。如果超过了，将直接执行当前格子对应的任务。</p>
<h5 id="工作线程为单线程"><a href="#工作线程为单线程" class="headerlink" title="工作线程为单线程"></a>工作线程为单线程</h5><p>执行所有任务的线程是单线程的，如果每个格子中的任务执行时间之和超过100ms，后续的所有任务将会受到影响，所以尽量不要提交执行时间很长的任务到HashedWheelTimer中。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="headerlink" title="缓存淘汰算法"></a>缓存淘汰算法</h3><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>LRU全称是Least Recently Used，即最近最少使用。当缓存需要清理时，清除最近一段时间没有使用过的数据。</p>
<p>数据结构：双向链表+哈希表</p>
<p>算法复杂度：一般情况下为O(1)，特殊情况下由于哈希碰撞严重，可能会退化为O(N)</p>
<p>通过一个双向链表存储所有的节点，如果某个数据被访问，那么将该节点移动到链表最开始，需要淘汰时，将链表最后一个节点移除。为了方便查询，在哈希表中存储的数据结构为key:(value,point),其中point表示该数据在链表中的指针，方便移动时能快速找到链表中的节点。</p>
<h4 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h4><p>LFU 即Least Frequently Used，最近最少使用。当缓存需要清理时，清除最近使用次数最少的数据。</p>
<p>数据结构：TreeMap + 哈希表  + 双向链表</p>
<p>算法复杂度：一般情况下为O(1)，特殊情况下由于哈希碰撞严重，可能会退化为O(N)</p>
<p>在TreeMap中保存访问次数与访问次数对应的数据，相同的访问次数可能对应多个数据，这些数据通过双向链表进行保存。哈希表中的数据结构为key:(value,point),其中point表示该数据在双向链表中的指针，方便修改访问次数时可以快速在链表中移除该节点并添加到新的链表中。</p>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>FIFO 即First In First Out，先进先出。当缓存需要清理时，清除最先加入缓存的数据。</p>
<p>数据结构：双向链表 + 哈希表</p>
<p>算法复杂度：一般情况下为O(1)，特殊情况下由于哈希碰撞严重，可能会退化为O(N)</p>
<p>通过双向链表保存数据的加入顺序，新加入的数据添加到队尾，需要清理时，移除队头数据。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="分布式系统设计原则：CAP原则"><a href="#分布式系统设计原则：CAP原则" class="headerlink" title="分布式系统设计原则：CAP原则"></a>分布式系统设计原则：CAP原则</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/szlbm/p/5588543.html">https://www.cnblogs.com/szlbm/p/5588543.html</a><ul>
<li>C:一致性(Consistency)，A:可用性(Availability)，P:分区容错性(Partition tolerance)</li>
<li>分布式系统必须实现分区容错性，所以P必须实现</li>
<li>CA不能同时满足：因为网络是不可靠的，要实现分区之间数据一致，必须依赖与网络。如果需要强一致性，网络故障时会导致不可用(without A)，如果需要保证可用性，则网络故障时只能用旧值(without C)</li>
</ul>
</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gg4q_53eiHCI3OUWzN7eWg">https://mp.weixin.qq.com/s/gg4q_53eiHCI3OUWzN7eWg</a></p>
<h4 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h4><p>2PC(two phase commit)的一种实现，分别需要执行预提交(precommit)和提交(commit)两个阶段，需要底层数据库支持。</p>
<p>缺点：</p>
<ol>
<li>需要事务管理器进行协调，如果事务管理器故障会导致资源阻塞</li>
<li>最终提交前，资源一直被阻塞，性能差</li>
<li>网络问题导致多个服务没有同时提交或同时回滚，导致数据不一致</li>
</ol>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p><a target="_blank" rel="noopener" href="https://www.bytesoft.org/">https://www.bytesoft.org/</a></p>
<p><code>TCC</code>分为三个操作，分别是<code>try</code>、<code>confirm</code>、<code>cancel</code>，其中每一个操作都是完整的本地事务。</p>
<ul>
<li><p>try：尝试执行业务检查和准备操作，例如转账前检查余额，并将余额进行冻结。</p>
</li>
<li><p>confirm：如果所有从属业务<code>try</code>操作均成功执行，则依次执行<code>confirm</code>。<code>confirm</code>不允许业务异常，例如冻结金额不足等业务问题。如果执行失败，则将不断重试，所以需要保证幂等。例如将<code>try</code>操作冻结的余额进行扣除。</p>
</li>
<li><p>cancel：如果有任何一个从属业务<code>try</code>失败，则执行所有<code>try</code>成功业务对应的<code>cancel</code>操作。如果执行失败，将不断重试，需要保证幂等。例如将<code>try</code>操作冻结的金额释放。</p>
</li>
</ul>
<h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>有些情况下，不需要保证数据的强一致性，只需要保证数据的<code>最终一致性</code>，即允许数据在某个阶段不一致，但最终一定是一致的。</p>
<p>通过本地消息表+本地事务实现</p>
<p><img src="/images/640" alt="img"></p>
<p>例如：扣除余额业务需要修改用户余额的同时，记录一条流水记录，这两个操作均由两个子系统实现，无法使用本地事务。</p>
<p>可以增加一张本地消息表，每次扣除余额时，在本地消息表中记录流水，并设置状态为未处理；在记录流水记录的事务中进行余额扣除，如果扣除成功则提交本地事务；如果不成功则回滚本地事务。</p>
<p>如果本地事务提交成功成功，说明本地流水和余额扣除操作均成功，可以同步&#x2F;异步通知流水系统记录流水，记录流水业务需要保证幂等，在一次通知不成功的情绪，将需要不断重试。</p>
<p>当流水系统成功记录流水后，通知主业务系统，主业务系统修改本地消息表中对应流水的状态为已完成，后续不再继续重试。</p>
<h4 id="saga事务"><a href="#saga事务" class="headerlink" title="saga事务"></a>saga事务</h4><p>将主业务拆分成若干子业务操作为：T1, T2, T3, …, Tn</p>
<p>定义所有子业务操作的反操作：C1, C2, C3, …, Cn</p>
<p>业务按次序执行，如果全部正常执行完成，则主业务执行完成；如果执行到某个业务失败，则按次序执行反操作。</p>
<p>例如T1, T2, …, Tj均执行成功，Tj+1执行失败，则依次执行Cj,…, C2, C1进行业务撤销</p>
<p>这种方案跟<code>TCC</code>比较没有<code>try</code>&amp;<code>confirm</code>的过程，例如增加余额操作没有先冻结余额再解冻金额，而是一步直接增加，会导致需要执行反操作（扣除余额）的时候，发现余额不足了，就无法正常执行反操作了。这就是事务之间没有隔离性的问题。</p>
<h4 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h4><p><a target="_blank" rel="noopener" href="https://github.com/seata/seata">https://github.com/seata/seata</a></p>
<h4 id="ByteTCC"><a href="#ByteTCC" class="headerlink" title="ByteTCC"></a>ByteTCC</h4><p><a target="_blank" rel="noopener" href="https://github.com/liuyangming/ByteTCC">https://github.com/liuyangming/ByteTCC</a></p>
<h3 id="文件IO性能"><a href="#文件IO性能" class="headerlink" title="文件IO性能"></a>文件IO性能</h3><p><a target="_blank" rel="noopener" href="https://www.cnkirito.moe/file-io-best-practise/">https://www.cnkirito.moe/file-io-best-practise/</a></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="缓存失效策略"><a href="#缓存失效策略" class="headerlink" title="缓存失效策略"></a>缓存失效策略</h4><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d7c7a14f265da03f47c4f93">https://juejin.im/post/5d7c7a14f265da03f47c4f93</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p>
<p>一般情况下，先写数据库再删除缓存，当数据已失效并有读写线程并发时，才有可能出校小概率读进程把脏数据写入缓存的情况发生。</p>
<p>可以通过异步MQ消息、binlog订阅更新、分布式读写锁等方式提高一致性。</p>
<p>更新时选择删除缓存而不是更新缓存是由于更新的数据不一定是热点数据，直接写入内存浪费空间，而且缓存数据可能是经过加工，非热点数据提前处理也浪费性能。</p>
<p>对性能要求高的数据可以考虑通过数据异步刷盘的方式，参考操作系统中的<code>PageCache</code>，数据读写全走缓存，写数据通过定时任务异步刷盘。该方案有丢数据的风险。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>当大量请求（可能是非法请求）查询一个不存在的值时，由于无法命中缓存，所以这些请求全部会打到数据库层从而导致数据库问题。</p>
<p>解决方案：</p>
<ul>
<li>在缓存中存储空值</li>
<li>使用布隆过滤器，在查询数据库前判断数据是否存在，如果不存在则不需要进行数据库查询。跟缓存空值比较的差别是这种方式占用内存更小，可以避免大量非法查询导致缓存空间不足；缺点是对于不存在的值可能会误判。</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>当有大量请求查询同一个缓存值时，如果这个缓存刚好失效了，那么就会出现这些请求都会打到数据库层。同样冷启动时也可能会有这样的问题。</p>
<p>解决方案：</p>
<ul>
<li>使用互斥锁，确保同一时刻只有一个线程执行数据库查询操作</li>
<li>冷启动时对于热点数据数据可以考虑缓存预热</li>
<li>热点数据可以定时刷新缓存，保证缓存一直能命中</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩可能由于缓存服务宕机、同一时刻大量缓存到期等原因造成</p>
<p>解决方案：</p>
<ul>
<li>保障缓存服务高可用</li>
<li>避免大量缓存在同一时刻到期，可以在过期时间上增加随机值</li>
<li>热点数据保证一直能命中缓存，参考<code>缓存击穿</code></li>
<li>使用本地缓存缓解压力</li>
<li>数据库查询限流、快速失败等</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ol>
<li>轮询：固定顺序依次请求</li>
<li>权重轮询：设置每台机器的权重后，依次请求</li>
<li>随机：每次请求随机分配</li>
<li>权重随机：可设置权重的随机</li>
<li>响应速度均衡：选择连接响应速度（例如ping）最快的机器连接</li>
<li>最少连接数：选择连接数最少的机器</li>
<li>处理能力均衡：根据当前集群中每台机器的CPU、内存、连接数等均衡评分，选择负载最小的机器</li>
<li>哈希：根据某个参数进行哈希分配机器，保证相同的参数发给同一台机器</li>
<li>URL哈希：根据请求地址哈希分配，保证相同地址的请求发给同一台机器</li>
</ol>
<h3 id="一致性算法"><a href="#一致性算法" class="headerlink" title="一致性算法"></a>一致性算法</h3><h4 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linbingdong/p/6253479.html">https://www.cnblogs.com/linbingdong/p/6253479.html</a></p>
<h4 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h4><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ae1476ef265da0b8d419ef2">https://juejin.im/post/5ae1476ef265da0b8d419ef2</a></p>
<h3 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h3><p>消费端限流：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%BA-RocketMQ-%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA">Sentinel 为 RocketMQ 保驾护航</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Java协程库"><a href="#Java协程库" class="headerlink" title="Java协程库"></a>Java协程库</h3><p><a target="_blank" rel="noopener" href="https://github.com/kilim/kilim">kilim</a></p>
<p><a target="_blank" rel="noopener" href="https://colobu.com/2016/07/14/Java-Fiber-Quasar/">Quasar</a></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>强引用</li>
<li>软引用：GC时不会立即回收，只有当内存不足时回收</li>
<li>弱引用：GC是无论内存是否足够，都会被回收</li>
<li>虚引用：不影响GC，用来判断某个对象是否被回收</li>
</ul>
<h3 id="CPU-load和使用率的关系"><a href="#CPU-load和使用率的关系" class="headerlink" title="CPU load和使用率的关系"></a>CPU load和使用率的关系</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rexcheny/p/9382396.html">https://www.cnblogs.com/rexcheny/p/9382396.html</a></p>
<p>CPU load是在一段时间内CPU正在处理以及等待CPU处理的进程数之和</p>
<p>CPU使用率是指进程对cpu占用的时间比例</p>
<p>例如只有一个进程使用一颗单核CPU，IO等待了15ms，CPU计算了45ms，那么此时的CPU load是1，CPU 使用率是75%</p>
<h3 id="Java字节码增强探秘"><a href="#Java字节码增强探秘" class="headerlink" title="Java字节码增强探秘"></a>Java字节码增强探秘</h3><p> <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/kzmlUsizYFlw7F9t5jPO">https://www.infoq.cn/article/kzmlUsizYFlw7F9t5jPO</a></p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p><a target="_blank" rel="noopener" href="https://github.com/javagrowing/JGrowing/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO/%E8%B5%B0%E8%BF%9B%E7%A7%91%E5%AD%A6%E4%B9%8B%E6%8F%AD%E5%BC%80%E7%A5%9E%E7%A7%98%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D.md">走进科学之揭开神秘的零拷贝</a></p>
<p>一般一次读文件写文件（网络流）操作的伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File.read(file, buf, len);</span><br><span class="line">Socket.send(socket, buf, len);</span><br></pre></td></tr></table></figure>

<p>DMA：Direct Memory Access 实现主存与I&#x2F;O设备之间数据交换不需要依赖CPU</p>
<p>期间经历了四次数据拷贝，分别为：</p>
<ol>
<li>CPU发指令给I&#x2F;O设备的DMA，由DMA将我们磁盘中的数据传输到内核空间的内核buffer。</li>
<li>第二阶段触发我们的CPU中断，CPU开始将将数据从kernel buffer拷贝至我们的应用缓存</li>
<li>CPU将数据从应用缓存拷贝到内核中的socket buffer.</li>
<li>DMA将数据从socket buffer中的数据拷贝到网卡缓存</li>
</ol>
<p>其中1、4部分不消耗CPU资源</p>
<p>其中步骤2可以省略，通过FileChannel的transferTo() 方法可以直接将数据从文件通道直接写入目标写字节通道，即数据不拷贝到用户态内存中，仅加载入内核缓冲区，所以不需要CPU参与进行数据拷贝。</p>
<p>Linux2.4以后进行了优化，可以将从文件中读取到内核中的数据信息追加到套接字缓冲区，此时数据将可以直接从内核缓冲区直接拷贝到协议引擎，此次拷贝不需要消耗CPU</p>
<h2 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h2><ul>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/">https://javadoop.com</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/xingshaocheng/architect-awesome">https://github.com/xingshaocheng/architect-awesome</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/javagrowing/JGrowing">https://github.com/javagrowing/JGrowing</a></li>
</ul>
<h2 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h2><p>阿里巴巴长期招人，HC无限，要求无上限、待遇无上限，欢迎加入，有意可联系邮箱：<a href="mailto:&#101;&#101;&#101;&#108;&#x69;&#110;&#122;&#x68;&#x6f;&#117;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;">&#101;&#101;&#101;&#108;&#x69;&#110;&#122;&#x68;&#x6f;&#117;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a> ，其他联系方式详见<a href="/about/">关于</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>如果这篇文章对你有帮助，可以请作者喝杯咖啡~</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.JPG" alt="Elin Zhou 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.JPG" alt="Elin Zhou 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/04/15/database-performance-optimization/" rel="next" title="数据库垂直切分迁移">
      数据库垂直切分迁移 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81JUC"><span class="nav-number">1.1.</span> <span class="nav-text">多线程、JUC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.2.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM"><span class="nav-number">1.3.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO"><span class="nav-number">1.4.</span> <span class="nav-text">NIO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">2.</span> <span class="nav-text">框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-number">2.1.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RocketMQ"><span class="nav-number">2.2.</span> <span class="nav-text">RocketMQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat"><span class="nav-number">2.3.</span> <span class="nav-text">Tomcat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty"><span class="nav-number">2.4.</span> <span class="nav-text">Netty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hystrix"><span class="nav-number">2.5.</span> <span class="nav-text">Hystrix</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">3.1.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-number">3.2.</span> <span class="nav-text">MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZooKeeper"><span class="nav-number">3.3.</span> <span class="nav-text">ZooKeeper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HBase%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">3.4.</span> <span class="nav-text">HBase设计原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MongoDB-ElasticSearch%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.</span> <span class="nav-text">MongoDB&#x2F;ElasticSearch设计原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">常用设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">5.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.1.</span> <span class="nav-text">TCP&#x2F;IP 四层协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.2.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP"><span class="nav-number">5.3.</span> <span class="nav-text">HTTP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">6.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-number">6.1.</span> <span class="nav-text">源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">缓存淘汰算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">8.</span> <span class="nav-text">架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9ACAP%E5%8E%9F%E5%88%99"><span class="nav-number">8.1.</span> <span class="nav-text">分布式系统设计原则：CAP原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">8.2.</span> <span class="nav-text">分布式事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6IO%E6%80%A7%E8%83%BD"><span class="nav-number">8.3.</span> <span class="nav-text">文件IO性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">8.4.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">8.5.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95"><span class="nav-number">8.6.</span> <span class="nav-text">一致性算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7"><span class="nav-number">8.7.</span> <span class="nav-text">削峰填谷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">9.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%8D%8F%E7%A8%8B%E5%BA%93"><span class="nav-number">9.1.</span> <span class="nav-text">Java协程库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">9.2.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-load%E5%92%8C%E4%BD%BF%E7%94%A8%E7%8E%87%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">9.3.</span> <span class="nav-text">CPU load和使用率的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E6%8E%A2%E7%A7%98"><span class="nav-number">9.4.</span> <span class="nav-text">Java字节码增强探秘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">9.5.</span> <span class="nav-text">零拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90"><span class="nav-number">10.</span> <span class="nav-text">博客推荐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E4%B8%AA%E5%B9%BF%E5%91%8A"><span class="nav-number">11.</span> <span class="nav-text">打个广告</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Elin Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Elin Zhou</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'O8tbbpNbwImnAhnEHIQT6gue-gzGzoHsz',
      appKey     : 'OQR4QQj44MeKsBbdBEfneTeA',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
