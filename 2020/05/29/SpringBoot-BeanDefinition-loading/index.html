<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PingFang SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.xxelin.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="为什么要强调SpringBoot中的BeanDefinition加载过程？在阅读很多相对比较旧的讲解Spring容器的书籍或文章时，由于当时SpringBoot并不是很盛行，甚至还没有SpringBoot，导致对于Spring容器启动的讲解并没有提到与SpringBoot容器启动过程的差异，导致很多读者默认为这两者是一样的。 事实上，在容器启动时，传统的配置式的Spring项目与使用了Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot BeanDefinition 加载过程">
<meta property="og:url" content="https://www.xxelin.com/2020/05/29/SpringBoot-BeanDefinition-loading/index.html">
<meta property="og:site_name" content="奕林的技术博客">
<meta property="og:description" content="为什么要强调SpringBoot中的BeanDefinition加载过程？在阅读很多相对比较旧的讲解Spring容器的书籍或文章时，由于当时SpringBoot并不是很盛行，甚至还没有SpringBoot，导致对于Spring容器启动的讲解并没有提到与SpringBoot容器启动过程的差异，导致很多读者默认为这两者是一样的。 事实上，在容器启动时，传统的配置式的Spring项目与使用了Spring">
<meta property="og:image" content="https://www.xxelin.com/images/image-20200529100923802.png">
<meta property="article:published_time" content="2020-05-29T08:28:40.000Z">
<meta property="article:modified_time" content="2020-05-29T08:32:35.537Z">
<meta property="article:author" content="Elin Zhou">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.xxelin.com/images/image-20200529100923802.png">

<link rel="canonical" href="https://www.xxelin.com/2020/05/29/SpringBoot-BeanDefinition-loading/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>SpringBoot BeanDefinition 加载过程 | 奕林的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">奕林的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">撸着代码唱着歌</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Elin-Zhou" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.xxelin.com/2020/05/29/SpringBoot-BeanDefinition-loading/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Elin Zhou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奕林的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringBoot BeanDefinition 加载过程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-29 16:28:40 / 修改时间：16:32:35" itemprop="dateCreated datePublished" datetime="2020-05-29T16:28:40+08:00">2020-05-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="为什么要强调SpringBoot中的BeanDefinition加载过程？"><a href="#为什么要强调SpringBoot中的BeanDefinition加载过程？" class="headerlink" title="为什么要强调SpringBoot中的BeanDefinition加载过程？"></a>为什么要强调SpringBoot中的BeanDefinition加载过程？</h2><p>在阅读很多相对比较旧的讲解<code>Spring容器</code>的书籍或文章时，由于当时<code>SpringBoot</code>并不是很盛行，甚至还没有<code>SpringBoot</code>，导致对于<code>Spring容器</code>启动的讲解并没有提到与<code>SpringBoot</code>容器启动过程的差异，导致很多读者默认为这两者是一样的。</p>
<p>事实上，在容器启动时，传统的配置式的<code>Spring</code>项目与使用了<code>SpringBoot</code>的项目在启动时大体上是相近的，但是区别也还是不小的，本文要提到的<code>BeanDefinition</code> 加载过程中是其中一个例子。</p>
<a id="more"></a>

<h2 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a>找不同</h2><p>因为讲解<code>Spring</code>启动过程的文章已经很多了，在这里不详细介绍这部分内容，但是为了让读者阅读更清晰，以及便于理解，我们从源码中寻找一下两种方式差异的原因。</p>
<p>这里假设读者已经自行阅读过<code>Spring</code>启动的相关文章了，所以我们知道，<code>Spring</code>启动的核心过程是<code>ApplicationContext#refresh</code>方法。而加载<code>BeanDefinition</code>实在<code>obtainFreshBeanFactory</code>方法中，贴一下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 刷新BeanFactory</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了<code>refreshBeanFactory</code>方法进行刷新容器，想进一步查询其源码时，发现这个方法有两个实现类，分别是<code>AbstractRefreshableApplicationContext</code>和<code>GenericApplicationContext</code>。</p>
<p>代码到了这里出现了分岔路口，我们看看具体应该进入哪个分支。先回想一下传统方式创建一个<code>Spring容器</code>的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/src/main/resources/spring.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>看一下<code>FileSystemXmlApplicationContext</code>类的类继承图</p>
<p><img src="/images/image-20200529100923802.png" alt="FileSystemXmlApplicationContext的类继承图"></p>
<p>可以发现<code>FileSystemXmlApplicationContext</code>继承<code>AbstractRefreshableApplicationContext</code>从而实现了<code>refreshBeanFactory</code>方法。我们进入<code>AbstractRefreshableApplicationContext#refreshBeanFactory</code>可以看到，跟我们之前了解的一样，在这里加载了<code>BeanDefinition</code>，简单贴一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">//如果原来已经存在了beanFactory，那么先销毁掉</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 手动创建一个DefaultListableBeanFactory</span></span><br><span class="line">      <span class="comment">// 当前类也是BeanFactory的子类，但是实际实现都是委托给这个beanFactory来处理的</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">//设置beanFactory的两个参数————是否允许Bean覆盖和是否允许循环依赖</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">//加载BeanDefinition,由子类实现，有不同的加载方式，如从XML中、注解配置中获取等等</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<code>SpringBoot</code>是如何呢？我们从代码中寻找答案。因为<code>SpringBoot</code>没有显示创建<code>ApplicationContext</code>的代码，我们只能从入口寻找。</p>
<p>一般情况下，我们是这么启动<code>SpringBoot</code>项目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SpringBoot</code>再神通广大，终归是用<code>Java</code>实现的，这个<code>main</code>方法我们再熟悉不过了，里面只调用了一个方法，即<code>SpringApplication#run</code>，那么秘密一定在里面。</p>
<p><code>run</code>方法里面调用了自己的重载方法，然后又调用了另一个重载方法，直到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,</span></span></span><br><span class="line"><span class="function"><span class="params">      String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续进入其<code>run</code>方法看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">      configureIgnoreBeanInfo(environment);</span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">            SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">            new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      listeners.started(context);</span><br><span class="line">      callRunners(context, applicationArguments);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners.running(context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法代码很长，但我们的目的是找到<code>ApplicationContext</code>的实现类，所以我们不关心其他逻辑，在这里寻找<code>ApplicationContext</code>。</p>
<p>很容易在第四行就找到<code>ConfigurableApplicationContext</code>类型的声明，可惜这里只有接口，没有实现类，但是通过<code>context</code>变量，我们可以很容易找到赋值的代码，第16行。从调用的方法名也可以确认，就是在<code>createApplicationContext</code>中创建了上下文，我们看一下其实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">   <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 根据当前的应用类型，获取正确的类名</span></span><br><span class="line">         <span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) &#123;</span><br><span class="line">         <span class="keyword">case</span> SERVLET:</span><br><span class="line">            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> REACTIVE:</span><br><span class="line">            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">               <span class="string">"Unable create a default ApplicationContext, "</span></span><br><span class="line">                     + <span class="string">"please specify an ApplicationContextClass"</span>,</span><br><span class="line">               ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 实例化对象</span></span><br><span class="line">   <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不出所料，在<code>createApplicationContext</code>方法中判断了应用环境选择了对应的上下文类型，并且将其实例化，也可以很容易发现，这里三个分支所对应的三个类，均继承自<code>GenericApplicationContext</code>。</p>
<p>  到这里，我们终于在代码中找到两种方式启动的差异点，我们看一下<code>GenericApplicationContext#refreshBeanFactory</code>方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以说是几乎什么也没做，只设置了一个序列化id。完全找不到之前看的那些加载<code>BeanDefinition</code>的代码。至此可以确定，<code>SpringBoot</code>项目的加载<code>BeanDefinition</code>过程并不在此处。</p>
<h2 id="SpringBoot-加载-BeanDefinition的入口"><a href="#SpringBoot-加载-BeanDefinition的入口" class="headerlink" title="SpringBoot 加载 BeanDefinition的入口"></a>SpringBoot 加载 BeanDefinition的入口</h2><p>那么<code>SpringBoot</code>具体是通过什么方式方式加载项目中的所有<code>BeanDefinition</code>的呢？</p>
<p>其实<code>SpringBoot</code>中，是通过<code>@Configuration</code>注解来作为所有配置的入口标记的，例如上文中的例子，<code>Application</code>类被添加了<code>@SpringBootApplication</code>注解，而<code>@SpringBootApplication</code>有被<code>@SpringBootConfiguration</code>注解标记，而<code>@SpringBootConfiguration</code>正是<code>@Configuration</code>的子类。</p>
<p>那么具体是在哪里提供了扫描<code>@Configuration</code>注解并加载所有配置的功能，在这里就不卖关子了，直接介绍本文的主角 <code>ConfigurationClassPostProcessor</code></p>
<h2 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h2><p>我们先简单看一下这个类的继承关系，发现它继承自<code>BeanDefinitionRegistryPostProcessor</code>，关于这个类在<a href="/2020/04/15/spring-extend-interface/#BeanDefinitionRegistryPostProcessor">Spring支持的扩展接口</a>一文中介绍过，其中介绍<code>postProcessBeanDefinitionRegistry</code>方法内容如下：</p>
<blockquote>
<p>该方法在所有<code>BeanDefinition</code>被加载完成后，<code>BeanFactoryPostProcessor#postProcessBeanFactory</code>之前被调用。</p>
<p>可以在此处修改已加载的<code>BeanDefinition</code>，或添加自定义的<code>BeanDefinition</code>，来实现动态注册<code>Bean</code>；也可以在此方法中注册其他<code>BeanDefinitionRegistryPostProcessor</code>，但如果当前Bean也是被其他<code>BeanDefinitionRegistryPostProcessor#postProcessBeanFactory</code>加载的，那么当前<code>Bean</code>加载的<code>BeanDefinitionRegistryPostProcessor</code>将没有机会被执行。</p>
</blockquote>
<p>这个方法功能正好符合我们对<code>ConfigurationClassPostProcessor</code>这个类功能的期待，那么接下来看<code>ConfigurationClassPostProcessor#postProcessBeanFactory</code>的实现是否符合预期。</p>
<p>还是按照惯例贴上包括简单注释的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 为当前的BeanFactory生成一个id，防止同一个BeanFactory被重复处理</span></span><br><span class="line">   <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">   <span class="comment">// 处理配置的BeanDefinitions</span></span><br><span class="line">   processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现这个方法中没有太多秘密，只是做了一个简单的检查，最终调用了<code>processConfigBeanDefinitions</code>方法，深入看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">   String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">   <span class="comment">// 遍历当前容器中所有的BeanDefinition，从中寻找有@Configuration的类</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">      BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">      <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||</span><br><span class="line">            ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否有@Configuration注解，如果有就加入候选列表</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">         configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果候选列表为空，就直接返回了</span></span><br><span class="line">   <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果使用了@Order注解，就排个序</span></span><br><span class="line">   Collections.sort(configCandidates, <span class="keyword">new</span> Comparator&lt;BeanDefinitionHolder&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">         <span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">         <span class="keyword">return</span> (i1 &lt; i2) ? -<span class="number">1</span> : (i1 &gt; i2) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">   SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">      sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">         BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">         <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">         <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面开始解析候选列表</span></span><br><span class="line">   <span class="comment">// 创建一个ConfigurationClassParser，后面的解析将委托给这个对象</span></span><br><span class="line">   ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">         <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">         <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates);</span><br><span class="line">   Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;ConfigurationClass&gt;(configCandidates.size());</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">//开始解析，细讲</span></span><br><span class="line">      parser.parse(candidates);</span><br><span class="line">      parser.validate();</span><br><span class="line"></span><br><span class="line">      Set&lt;ConfigurationClass&gt; configClasses =</span><br><span class="line">            <span class="keyword">new</span> LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses());</span><br><span class="line">      configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果BeanDefinitionReader为空，则创建一个，BeanDefinitionReader是用来加载BeanDefinition</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">               registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">               <span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 前面ConfigurationClassParser#parse处理时遗留了三类类型，只将其解析并保存，并没有注册成BeanDefinition，在这个方法中进行处理</span></span><br><span class="line">      <span class="comment">// 使用BeanDefinitionReader进行加载BeanDefinition，细讲</span></span><br><span class="line">      <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">      alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">      candidates.clear();</span><br><span class="line">      <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">         <span class="comment">// 如果发现当前容器中的BeanDefinition数量比上一轮解析完以后的数量多，说明这一轮解析了新的BeanDefinition</span></span><br><span class="line">         <span class="comment">// 这种情况需要对BeanDefinition列表逐个判断，如果其类型加了@Configuration注解，那么需要放入候选列表中，进行下一轮解析</span></span><br><span class="line">         String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">         Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(candidateNames));</span><br><span class="line">         Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">         <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">               BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">               <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                     !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                  candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         candidateNames = newCandidateNames;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">   <span class="keyword">if</span> (sbr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">         sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">      ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者可以先通过代码外加笔者加的的中文注释对这个方法有个大致的理解，其实可以很容易发现这个方法正是用来处理<code>@Configuration</code>注解的。</p>
<p>简单总结一下这个方法中的流程：</p>
<ol>
<li>从当前已注册的<code>BeanDefinition</code>中找出有<code>@Configuration</code>的类作为候选集</li>
<li>排序</li>
<li>遍历候选集<ol>
<li>解析</li>
<li>加载解析完的<code>BeanDefinition</code></li>
<li>如果有新的<code>BeanDefinition</code>被加载，需要判断其是否被<code>@Configuration</code>标记，如果是则加入候选集</li>
</ol>
</li>
</ol>
<p>在执行这个方法前，被<code>@SpringBootApplication</code>标记的类（即项目的入口类）的<code>BeanDefinition</code>已经被注册到了<code>Spring</code>中，所以在第一步中就会被加入到候选集中。</p>
<p>在接下来的步骤解析和加载<code>BeanDefinition</code>时，会通过特定的规则进行扫描，详细内容后文继续介绍，主要是55行的<code>ConfigurationClassParser#parse</code>和70行的<code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitions</code>两个方法。</p>
<h2 id="解析配置类"><a href="#解析配置类" class="headerlink" title="解析配置类"></a>解析配置类</h2><p>上文提到过，<code>ConfigurationClassPostProcessor</code>在处理<code>BeanDefinition</code>时，需要进行解析操作，而解析操作是委托给<code>ConfigurationClassParser</code>类处理的，这个类的作用通过类名就可以知道，就是用来解析配置类的，我们看一下其<code>parse</code>方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.deferredImportSelectors = <span class="keyword">new</span> LinkedList&lt;DeferredImportSelectorHolder&gt;();</span><br><span class="line">   <span class="comment">// 依次解析所有候选BeanDefinition</span></span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">      BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">            parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">               <span class="string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 处理前面在解析@Import注解中为DeferredImportSelector子类的对象</span></span><br><span class="line">   processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>parse</code>方法依次遍历了所有的候选配置类，然后根据类型的不同，调用了不同的解析方法，其实三个分支最终都是调用了同一个实现方法，只是要根据类型不同做不同的准备。通过追踪代码，可以发现其最终调用的是<code>processConfigurationClass</code>方法。</p>
<p>接下来单独分析一下<code>processConfigurationClass</code>和<code>processDeferredImportSelectors</code>两个方法。</p>
<h3 id="processConfigurationClass"><a href="#processConfigurationClass" class="headerlink" title="processConfigurationClass"></a>processConfigurationClass</h3><p>先贴上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">// 如果当前类使用了@Conditional注解，则需要根据条件判断是否要跳过该类的解析</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">   <span class="comment">//判断当前类是否已经解析过，防止重复解析</span></span><br><span class="line">   <span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">            <span class="comment">//如果是被@Import注解导入的，那么记录一下</span></span><br><span class="line">            existingClass.mergeImportedBy(configClass);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 直接结束了，不需要重复解析</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果当前类不是被其他类通过@Import注解导入的，说明其是被显式定义的（说明一个类被定义了两次），那么将旧的移除。（重新解析一次）</span></span><br><span class="line">         <span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">         <span class="keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="keyword">this</span>.knownSuperclasses.values().iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (configClass.equals(it.next())) &#123;</span><br><span class="line">               it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">   SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 进行递归解析，直到该类没有父类为止，重头戏，细讲</span></span><br><span class="line">      sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了三件事：</p>
<p>第一判断当前类是否需要解析，判断委托给了<code>ConditionEvaluator</code>类进行处理，这个类型是根据当前类的<code>@Conditional</code>注解进行处理的，关于这个注解的使用如果有不了解的读者可以自行学习一下，其用法与实现与本文主要内容无关，在此不再展开叙述。</p>
<p>第二是判断当前类是否已经被加载过，如果是被<code>@Import</code>依赖的，那么记录一下就直接返回不重复处理了；如果不是被<code>@Import</code>依赖的，那么就再解析一遍（会把上一次的解析结果覆盖）。</p>
<p>第三就是具体解析的调用，回调用<code>doProcessConfigurationClass</code>方法进行处理，可以发现这个方法被一个循环所包围，因为方法的会返回当前类型的父类，如果其父类存在，则会循环解析，知道不存在父类时，会返回<code>null</code>。</p>
<p>那么看一下<code>doProcessConfigurationClass</code>方法的实现，这个方法基本已经到了本文的核心逻辑，读者先根据注释对其有大概了解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">// 递归处理当前类的内部类</span></span><br><span class="line">   processMemberClasses(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理@PropertySource注解</span></span><br><span class="line">   <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), PropertySources<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">         <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">context</span>.<span class="title">annotation</span>.<span class="title">PropertySource</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">         <span class="comment">// 解析PropertySource注解中的value字段，依次加载配置文件</span></span><br><span class="line">         processPropertySource(propertySource);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.warn(<span class="string">"Ignoring @PropertySource annotation on ["</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">               <span class="string">"]. Reason: Environment must implement ConfigurableEnvironment"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理@ComponentScan注解</span></span><br><span class="line">   Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">         sourceClass.getMetadata(), ComponentScans<span class="class">.<span class="keyword">class</span>, <span class="title">ComponentScan</span>.<span class="title">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">         !<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">      <span class="comment">// @Conditional注解优先判断</span></span><br><span class="line">      <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">         <span class="comment">// 根据@ComponentScan中的参数进行扫描，实际上是委托给ClassPathBeanDefinitionScanner处理</span></span><br><span class="line">         Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">               <span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">         <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">         <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">            BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">            <span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">               bdCand = holder.getBeanDefinition();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">               <span class="comment">// 如果新解析到的BeanDefinition使用了@Configuration，直接递归解析</span></span><br><span class="line">               parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理@Import注解</span></span><br><span class="line">   processImports(configClass, sourceClass,</span><br><span class="line">         <span class="comment">//提取出@Import注解需要导入的类型</span></span><br><span class="line">         getImports(sourceClass),</span><br><span class="line">         <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理@ImportResource注解</span></span><br><span class="line">   <span class="keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">      AnnotationAttributes importResource =</span><br><span class="line">            AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      String[] resources = importResource.getStringArray(<span class="string">"locations"</span>);</span><br><span class="line">      Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">"reader"</span>);</span><br><span class="line">      <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">         String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">         <span class="comment">// 将配置的资源存起来，后面会统一处理</span></span><br><span class="line">         configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理@Bean注解</span></span><br><span class="line">   Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">   <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">      <span class="comment">//解析添加了@Bean注解的放放，并存起来，后面统一处理</span></span><br><span class="line">      configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 递归查询并处理接口中的@Bean注解</span></span><br><span class="line">   processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断是否有父类，如果有父类，则返回，外层会递归调用；如果没有则返回null，结束解析</span></span><br><span class="line">   <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">      String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">      <span class="keyword">if</span> (!superclass.startsWith(<span class="string">"java"</span>) &amp;&amp; !<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">         <span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">         <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">         <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三行调用<code>processMemberClasses</code>方法用来处理当前类的内部类，获取当前类的内部类，并循环递归调用<code>processConfigurationClass</code>方法。这个方法的具体实现感兴趣的读者可自行阅读，比较简单不再展开。</p>
<p>上文说到当前方法是本文的核心方法，是因为可以发现该方法的代码中，依次处理了配置类中所需要处理的五个注解，下文只会大概介绍其处理的原理，有些细节不再展开。</p>
<h4 id="处理-PropertySource"><a href="#处理-PropertySource" class="headerlink" title="处理@PropertySource"></a>处理@PropertySource</h4><p><code>@PropertySource</code>用来实现将指定的配置文件加载到当前<code>Spring</code>环境中</p>
<h4 id="处理-ComponentScan"><a href="#处理-ComponentScan" class="headerlink" title="处理@ComponentScan"></a>处理@ComponentScan</h4><p><code>@ComponentScan</code>的作用是自动扫描指定包中的所有类，并根据其是否有特定注解（例如<code>@Service</code>、<code>@Component</code>等）将其转化为<code>BeanDefinition</code>加载当上下文中。</p>
<p>在此处的实现方式是将注解中配置的包路径依次委托给<code>ClassPathBeanDefinitionScanner</code>进行处理，关于<code>ClassPathBeanDefinitionScanner</code>已经在<a href="/2020/04/15/spring-utils/#ClassPathBeanDefinitionScanner">Spring常用工具</a>一文中大致介绍过，不再赘述。</p>
<p>在这一步如果解析到了新的<code>BeanDefinition</code>且使用了<code>@Configuration</code>注解，直接调用<code>parse</code>方法进行递归解析。</p>
<h4 id="处理-Import"><a href="#处理-Import" class="headerlink" title="处理@Import"></a>处理@Import</h4><p><code>@Import</code>可以将其他类引入当前上下文中，在该方法中，先通过<code>getImports</code>方法解析需要导入的类型，再调用<code>processImports</code>方法处理这些类型</p>
<p>先贴一下<code>processImports</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Collection&lt;SourceClass&gt; importCandidates, <span class="keyword">boolean</span> checkForCircularImports)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.problemReporter.error(<span class="keyword">new</span> CircularImportProblem(configClass, <span class="keyword">this</span>.importStack));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.importStack.push(configClass);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">            <span class="comment">//被导入的类型分为三类，依次处理</span></span><br><span class="line">            <span class="keyword">if</span> (candidate.isAssignable(ImportSelector<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">               <span class="comment">// 如果导入的是ImportSelector类型，则将其实例化，并调用其selectImports获取到真实需要导入的类名</span></span><br><span class="line">               Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">               ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">               ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                     selector, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.deferredImportSelectors != <span class="keyword">null</span> &amp;&amp; selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">                  <span class="comment">// 如果是DeferredImportSelector的子类，就将其放入deferredImportSelectors中，延迟加载，后面会处理</span></span><br><span class="line">                  <span class="keyword">this</span>.deferredImportSelectors.add(</span><br><span class="line">                        <span class="keyword">new</span> DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 非DeferredImportSelector子类，直接调用selectImports进行处理</span></span><br><span class="line">                  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">                  processImports(configClass, currentSourceClass, importSourceClasses, <span class="keyword">false</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">               <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">               <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">               <span class="comment">// 如果导入的类型是ImportBeanDefinitionRegistrar的子类，实例化并调用其Aware接口，将这些实例存起来，后面会统一处理</span></span><br><span class="line">               Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">               ImportBeanDefinitionRegistrar registrar =</span><br><span class="line">                     BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">               ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                     registrar, <span class="keyword">this</span>.environment, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.registry);</span><br><span class="line">               configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 即不是ImportSelector也不是ImportBeanDefinitionRegistrar的情况，当做有@Configuration注解的类处理，递归解析</span></span><br><span class="line">               <span class="keyword">this</span>.importStack.registerImport(</span><br><span class="line">                     currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">               processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">               <span class="string">"Failed to process import candidates for configuration class ["</span> +</span><br><span class="line">               configClass.getMetadata().getClassName() + <span class="string">"]"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.importStack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>processImports</code>方法中，循环处理每个需要导入的类型，根据其类型分为三种处理方式：</p>
<p>如果导入的类实现了<code>ImportSelector</code>接口：<code>ImportSelector</code>是一个动态导入接口，可以实现其<code>selectImports</code>方法，在该方法中根据条件返回最终需要导入的类。而在当前方法的实现则是会实例化这个<code>ImportSelector</code>子类，调用其<code>selectImports</code>方法获取需要导入的类型，并递归调用<code>processImports</code>方法。</p>
<p>不过此处有个例外，如果导入类实现了<code>DeferredImportSelector</code>接口，则不会在此处直接调用其<code>selectImports</code>方法，而会延迟调用，在此处只是进行记录，具体调用时机会在后文中提到。</p>
<p>如果导入类实现了<code>ImportBeanDefinitionRegistrar</code>接口：关于<code>ImportBeanDefinitionRegistrar</code>在<a href="ImportBeanDefinitionRegistrar/#ImportBeanDefinitionRegistrar">Spring支持的扩展接口</a>中介绍过，也提到了该类是由<code>@Import</code>引入并可使用的。具体实现是在此处将其实例化，并调用了几个<code>Aware</code>接口，再将其暂存起来，后文会再次提到。</p>
<p>如果不是上述的两种接口的子类：将该类当做普通的@Configuration注解的类处理，递归解析。</p>
<h4 id="处理-ImportResource"><a href="#处理-ImportResource" class="headerlink" title="处理@ImportResource"></a>处理@ImportResource</h4><p>使用<code>@ImportResource</code>可以将<code>xml</code>类型的配置导入并解析到当前项目中，但是在此处并没有真正进行解析，也将其暂存起来，在后面会统一处理。</p>
<h4 id="处理-Bean"><a href="#处理-Bean" class="headerlink" title="处理@Bean"></a>处理@Bean</h4><p><code>@Bean</code>是通过注解方式进行<code>Bean</code>定义最常用的方式，在此处扫描所有加了<code>@Bean</code>注解的方法并将其暂存，后面统一处理。</p>
<h3 id="处理DeferredImportSelectors接口实现"><a href="#处理DeferredImportSelectors接口实现" class="headerlink" title="处理DeferredImportSelectors接口实现"></a>处理DeferredImportSelectors接口实现</h3><p>上文提到，对于通过<code>@Import</code>导入的<code>DeferredImportSelector</code>子类需要延迟处理，正是在该方法中进行加载，处理逻辑基本与处理<code>ImportSelector</code>一致，不再赘述</p>
<h2 id="加载BeanDefinition"><a href="#加载BeanDefinition" class="headerlink" title="加载BeanDefinition"></a>加载BeanDefinition</h2><p>读者需要把思路重新回到<code>ConfigurationClassBeanDefinitionReader#processConfigBeanDefinitions</code>方法中，前文我们已经把<code>ConfigurationClassParser#parse</code>方法分析完了，接下来就是<code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitions</code>方法。</p>
<p>这里调用的方法名称为<code>loadBeanDefinitions</code>，直译过来就是加载<code>BeanDefinition</code>，但其实根据上面的阅读可以发现，前面解析时已经加载了很多<code>BeanDefinition</code>了，但是对于有些情况只做了记录，没有真正进行加载，而处理这些工作，正是<code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitions</code>做的事情。</p>
<p>贴一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> </span>&#123;</span><br><span class="line">   TrackedConditionEvaluator trackedConditionEvaluator = <span class="keyword">new</span> TrackedConditionEvaluator();</span><br><span class="line">   <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">      <span class="comment">// 再遍历一次候选类，加载之前未完成的工作</span></span><br><span class="line">      loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，遍历一下候选集，然后依次调用<code>loadBeanDefinitionsForConfigurationClass</code>方法，追踪到里面看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">      String beanName = configClass.getBeanName();</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="keyword">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">      <span class="comment">// 如果当前类是被@Import进来的，那么当前类型需要注册成BeanDefinition</span></span><br><span class="line">      registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//依次加载@Bean注解的方法</span></span><br><span class="line">   <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">      loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 加载@ImportResource注解对应的资源</span></span><br><span class="line">   loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">   <span class="comment">// 处理通过@Import导入的ImportBeanDefinitionRegistrar类型</span></span><br><span class="line">   loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面代码注释里面其实已经写得很清晰了，此处就是把上面遗留下来的几件事处理完成，分别是：</p>
<ol>
<li>将被<code>@Import</code>引入的类自身注册成<code>BeanDefinition</code></li>
<li>将被<code>@Bean</code>注解的方法解析成<code>BeanDefinition</code>并注册</li>
<li>加载被<code>@ImportResource</code>依赖的配置文件</li>
<li>被<code>@Import</code>导入的<code>ImportBeanDefinitionRegistrar</code>类在此处处理</li>
</ol>
<p>其中配置文件的加载，是被委托给对应的<code>BeanDefinitionReader</code>加载的，例如<code>xml</code>文件被委托给<code>XmlBeanDefinitionReader</code>处理，这个过程与传统的<code>Spring</code>项目的启动时加载配置文件的过程是一样的。</p>
<p>对于<code>ImportBeanDefinitionRegistrar</code>子类的处理过程是依次调用了其<code>registerBeanDefinitions</code>方法，而其子类可以在这个方法中动态加载<code>BeanDefinition</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，本文已经大致把<code>SpringBoot</code>中加载<code>BeanDefinition</code>的过程基本理了一遍，跟之前的源码分析风格一致，没有深入一些细节进行分析，尤其是本文的目的是介绍跟传统<code>Spring</code>容器加载<code>BeanDefinition</code>的差异，所以一些类似的功能就也没必要着重讲了。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>如果这篇文章对你有帮助，可以请作者喝杯咖啡~</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.JPG" alt="Elin Zhou 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.JPG" alt="Elin Zhou 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/26/BeanFactory-get-bean/" rel="prev" title="BeanFactory getBean源码分析">
      <i class="fa fa-chevron-left"></i> BeanFactory getBean源码分析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要强调SpringBoot中的BeanDefinition加载过程？"><span class="nav-number">1.</span> <span class="nav-text">为什么要强调SpringBoot中的BeanDefinition加载过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#找不同"><span class="nav-number">2.</span> <span class="nav-text">找不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot-加载-BeanDefinition的入口"><span class="nav-number">3.</span> <span class="nav-text">SpringBoot 加载 BeanDefinition的入口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConfigurationClassPostProcessor"><span class="nav-number">4.</span> <span class="nav-text">ConfigurationClassPostProcessor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解析配置类"><span class="nav-number">5.</span> <span class="nav-text">解析配置类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#processConfigurationClass"><span class="nav-number">5.1.</span> <span class="nav-text">processConfigurationClass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-PropertySource"><span class="nav-number">5.1.1.</span> <span class="nav-text">处理@PropertySource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-ComponentScan"><span class="nav-number">5.1.2.</span> <span class="nav-text">处理@ComponentScan</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-Import"><span class="nav-number">5.1.3.</span> <span class="nav-text">处理@Import</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-ImportResource"><span class="nav-number">5.1.4.</span> <span class="nav-text">处理@ImportResource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-Bean"><span class="nav-number">5.1.5.</span> <span class="nav-text">处理@Bean</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理DeferredImportSelectors接口实现"><span class="nav-number">5.2.</span> <span class="nav-text">处理DeferredImportSelectors接口实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载BeanDefinition"><span class="nav-number">6.</span> <span class="nav-text">加载BeanDefinition</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Elin Zhou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Elin Zhou</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

</body>
</html>
